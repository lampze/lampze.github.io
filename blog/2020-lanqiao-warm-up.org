#+TITLE:       2020蓝桥杯热身赛题解
#+AUTHOR:      shirui
#+EMAIL:       1229408499@qq.com
#+DATE:        2020-10-10 六
#+URI:         /blog/%y/%m/%d/2020-lanqiao-warm-up
#+KEYWORDS:    蓝桥杯, 算法, 题解
#+TAGS:        蓝桥杯, 算法, 题解
#+LANGUAGE:    zh
#+OPTIONS:     H:3 num:nil toc:nil \n:nil ::t |:t ^:nil -:nil f:t *:t <:t
#+DESCRIPTION: 2020蓝桥杯热身赛一的题解

* 前言
这次的热身赛填空题是我自己出的，后面的编程题直接使用了洛谷的题目。

* 题解
** 替罪羊树
*** 题目链接
https://www.luogu.com.cn/problem/T150941
*** 解题思路
这道题主要是让你们自己动手体会一下平衡树的算法，题目给定了一个不平衡的二叉搜索树，要求把这颗树重新构建成一个平衡的二叉搜索树，并且要求使用替罪羊算法。

这个算法简单来说就是获取全部元素，排序后找到最中间的元素，把这个元素设为根，然后对左边和右边的元素建成树，分别当作左右子树，当然左右子树生成的算法还是替罪羊算法。

因为只有15个结果，最后是一个完全树，答案唯一，因为数据少，直接手动画图就行了。
*** 答案
12 5 20 3 8 17 31 2 4 6 10 14 19 30 34
** 前缀和的查询次数
*** 题目链接
https://www.luogu.com.cn/problem/T150947
*** 解题思路
这道题考的是树状数组的思想，简单来说就是假设我已经维护好了一个树状数组，那么我想求第1到第2020个数的和需要查询多少次。

具体的做法我题目已经讲的很清楚了，这里就不过多讲述。

其实可以发现最后的答案就是2020转换成2进制后1的个数。
*** 答案
7
** π的神奇求法
*** 题目链接
https://www.luogu.com.cn/problem/T150512
*** 解题思路
[[https://www.bilibili.com/video/BV1bt41147H5][本题目数学上的解释]]

这道题很简单，直接找规律就行了。
*** 答案
314159265
** 方块的碰撞次数
*** 题目链接
https://www.luogu.com.cn/problem/T150513
*** 解题思路
然后我把上面的题目改了一下，这样最后的结果使用数学就不那么容易得出了，需要自己写一个程序来模拟这个系统，但其实我最后给了一点对于答案的提示，如果靠猜的话也有 10% 的几率成功。

模拟的话，只需要定义三个物体：墙、小方块、大方块。每个物体都有三个属性：位置、速度、质量。物体的碰撞满足却是守恒定律，可以计算出碰撞后物体的速度。当然墙需要特殊处理，因为墙不能动也没有速度。

然后我们也可以检测也这个系统有没碰撞， =t= 表示时间， =x= 表示位置， =v= 表示速度，如果碰撞的话，这两个物体的位置肯定是一样的，这样就可以得到一个公式 $$ t * v1 + x1 = t * v2 + x2 $$ ，为了简化，假设方块的边为0，所以这个公式没有考虑边长。

因为位置与速度已知，可以求出碰撞时间，如果时间为负说明在这两个物体并不会碰撞。

于是程序的思路很明显了，循环到整个系统没有碰撞为止，循环体每次计算碰撞后位置与速度即可。

因为只有三个物体，并且物体的顺序不可能变化，所以只有两个可能的碰撞点，即墙与小方块，小方块与大方块。

下面是我使用 =python= 写的模拟。

#+BEGIN_SRC python
def time(cub1, cub2):
    x1 = cub1[2]
    x2 = cub2[2]
    v1 = cub1[0]
    v2 = cub2[0]
    if (v2 - v1 == 0):
        return 0
    return (x1 - x2) / (v2 - v1)
def moveto(cub1, cub2):
    t = time(cub1, cub2)
    if t > 0:
        return ((cub1[0], cub1[1], cub1[2] + cub1[0] * t),
             (cub2[0], cub2[1], cub2[2] + cub2[0] * t))
    else:
        return False
def colliding(cub1, cub2):
    v1i = cub1[0]
    v2i = cub2[0]
    m1 = cub1[1]
    m2 = cub2[1]
    v1 = ((m1 - m2) / (m1 + m2)) * v1i + ((2 * m2) / (m1 + m2)) * v2i
    v2 = ((2 * m1) / (m1 + m2)) * v1i + ((m2 - m1) / (m1 + m2)) * v2i
    return ((v1, m1, cub1[2]), (v2, m2, cub2[2]))
def calc(cub1, cub2):
    temp = moveto(cub1, cub2)
    return colliding(temp[0], temp[1])
def check(cub1, cub2):
    if (time(cub1, cub2) > 0):
        return True
    else:
        return False
#(速度, 质量, 位置)
cub1 = (0, 1, 4)
cub2 = (-10, 2020, 20)
wall = (0, 1, 0)
count = 0
while check(cub1, cub2) or check(cub1, wall):
    if (cub1[0] < 0):
        t = time(cub1, wall)
        cub1 = (-cub1[0], cub1[1], 0)
        cub2 = (cub2[0], cub2[1], cub2[2] + t * cub2[0])
    else:
        (cub1, cub2) = calc(cub1, cub2)
    count += 1

return (cub1, cub2, count)
#+END_SRC
*** 答案
141
** test
*** 题目链接
*** 解题思路
*** 答案
** test
*** 题目链接
*** 解题思路
*** 答案
** test
*** 题目链接
*** 解题思路
*** 答案
** test
*** 题目链接
*** 解题思路
*** 答案
** test
*** 题目链接
*** 解题思路
*** 答案
** test
*** 题目链接
*** 解题思路
*** 答案
