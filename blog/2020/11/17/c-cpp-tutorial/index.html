<!DOCTYPE html>
<html lang="en-us">
  <head>
  <title>C/C++简明教程 - org-page</title>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta name="author" content="lampze" />
    <meta name="description" content="C/C++的简单教程" />
    <meta name="keywords" content="tutorial, C/C++" />
  <link rel="stylesheet" media="screen" href="/media/css/font.css" rel="stylesheet" type="text/css"/>
  <link rel="stylesheet" href="/media/css/main.css" type="text/css">
  <link rel="stylesheet" href="/media/css/prettify.css" type="text/css">
</head>

  <body class="container">
    <div>
  <header class="masthead">
    <h1 class="masthead-title"><a href="/">org-page</a></h1>
    <p>static site generator</p>
    <nav class="site-nav">
      <div class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z" fill="#ffff00"/>
          <path d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z" fill="#ffff00"/>
          <path d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z" fill="#ffff00"/>
        </svg>
      </div>
      <ul class="trigger">
          <li><a href="/blog/">Blog</a></li>
        <li><a href="/tags/">Tags</a></li>
        <li><a href="/about/">About</a></li>
        <li><a href="https://github.com/lampze/">GitHub</a></li>
        <li><a href="/rss.xml">RSS</a></li>
      </ul>
    </nav>
    <form method="get" id="searchform" action="//www.google.com/search">
      <input type="text" class="field" name="q" id="s" placeholder="Search">
      <input type="hidden" name="as_sitesearch" value="lampze.github.io">
    </form>
  </header>
</div>

    <div>
<div class="post">
<h1 class="title">C/C++简明教程</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org9916a9f">前言</a></li>
<li><a href="#org2391229">C语言</a>
<ul>
<li><a href="#org723908f">编程与运行流程</a>
<ul>
<li><a href="#org27c8f00">写代码</a></li>
<li><a href="#org04fd59b">编译</a></li>
<li><a href="#org37bef0c">运行过程</a></li>
</ul>
</li>
<li><a href="#org7a11518">语法简介</a></li>
<li><a href="#orgb1a85b5">变量</a>
<ul>
<li><a href="#orgf0e03f8">简介</a></li>
<li><a href="#org4cd1132">类型</a></li>
<li><a href="#org45a128e">创建</a></li>
<li><a href="#org7c7dbd7">使用</a></li>
</ul>
</li>
<li><a href="#org8e9f29e">输入输出</a>
<ul>
<li><a href="#org600cae8">简介</a></li>
<li><a href="#org78942a1">输出</a></li>
<li><a href="#orgb9a6e1a">输入</a></li>
</ul>
</li>
<li><a href="#orgebe21c8">选择</a>
<ul>
<li><a href="#org5ddafc6">简介</a></li>
<li><a href="#orga0ac063">if</a></li>
<li><a href="#org514809f">switch</a></li>
<li><a href="#org3898866">三元运算符</a></li>
</ul>
</li>
<li><a href="#org0afdb40">循环</a>
<ul>
<li><a href="#org27abb30">简介</a></li>
<li><a href="#org90d4187">while</a></li>
<li><a href="#org6cdc260">for</a></li>
</ul>
</li>
<li><a href="#orgf9a1339">数组</a>
<ul>
<li><a href="#orgf2643ec">简介</a></li>
<li><a href="#orgf9c44c4">语法</a></li>
<li><a href="#org848a286">插入排序</a></li>
</ul>
</li>
<li><a href="#orga3c7b8e">指针</a>
<ul>
<li><a href="#org6896adb">简介</a></li>
<li><a href="#org22e0e10">语法</a></li>
<li><a href="#orgfc16ad5">用法</a></li>
<li><a href="#org75fc66e">数组</a></li>
</ul>
</li>
<li><a href="#org4b80d3e">函数</a>
<ul>
<li><a href="#org2eade7a">简介</a></li>
<li><a href="#org351d603">语法</a></li>
<li><a href="#orgdb3cad7">例子</a></li>
</ul>
</li>
<li><a href="#org8f15a6d">递归</a>
<ul>
<li><a href="#orgc9ee58e">简介</a></li>
<li><a href="#orga1fad5b">fib</a></li>
</ul>
</li>
<li><a href="#orgf2900f6">结构体</a>
<ul>
<li><a href="#org900ba0b">简介</a></li>
<li><a href="#org1b7a733">语法</a></li>
<li><a href="#orgb662b24">结构体指针</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org07f255a">C++</a>
<ul>
<li><a href="#org8d59be3">stl</a></li>
<li><a href="#org0365e9a">输入输出</a>
<ul>
<li><a href="#orgc230faf">头文件</a></li>
<li><a href="#org47e84b4">cin</a></li>
<li><a href="#orgbd75d0b">cout</a></li>
<li><a href="#orgb45682e">总结</a></li>
</ul>
</li>
<li><a href="#orgd05fe31">vector</a>
<ul>
<li><a href="#org5d86a23">头文件</a></li>
<li><a href="#org6df67ba">简介</a></li>
<li><a href="#orgcebd33a">创建</a></li>
<li><a href="#org3283bc1">使用</a></li>
</ul>
</li>
<li><a href="#org2eaa8ee">string</a>
<ul>
<li><a href="#org1c05488">头文件</a></li>
<li><a href="#orgd4db4c6">简介</a></li>
<li><a href="#org62b9640">使用</a></li>
</ul>
</li>
<li><a href="#orgff16d8f">queue</a>
<ul>
<li><a href="#orga431643">头文件</a></li>
<li><a href="#org4f56c91">简介</a></li>
<li><a href="#org1ad2ba2">使用</a></li>
</ul>
</li>
<li><a href="#org23ed20e">stack</a>
<ul>
<li><a href="#org9a96ce5">头文件</a></li>
<li><a href="#orge8bfc8d">简介</a></li>
<li><a href="#org9e53b50">使用</a></li>
</ul>
</li>
<li><a href="#org151e06b">set</a>
<ul>
<li><a href="#org4a3e1ec">头文件</a></li>
<li><a href="#orga24712b">简介</a></li>
<li><a href="#org01a862a">使用</a></li>
</ul>
</li>
<li><a href="#org67910a2">map</a>
<ul>
<li><a href="#org1972e19">头文件</a></li>
<li><a href="#orgecc1a7e">简介</a></li>
<li><a href="#org2e09807">使用</a></li>
</ul>
</li>
<li><a href="#org86c0756">sort</a>
<ul>
<li><a href="#orgdcf9300">头文件</a></li>
<li><a href="#org79c612f">简介</a></li>
<li><a href="#org20fd55e">用法</a></li>
</ul>
</li>
<li><a href="#org7d1d80b">next_permutation</a>
<ul>
<li><a href="#orga7be4e3">头文件</a></li>
<li><a href="#org3ea9a21">简介</a></li>
<li><a href="#org19f27e2">使用方法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgb51b647">结语</a></li>
</ul>
</div>
</div>

<div id="outline-container-org9916a9f" class="outline-2">
<h2 id="org9916a9f">前言</h2>
<div class="outline-text-2" id="text-org9916a9f">
<p>
编程语言是让我们使用一个大部分人能理解的方式控制计算机，所以写代码时最重要的是可读性，对自己要求高的同学可以思考怎么保持代码的整洁与优雅。<br />
</p>

<p>
本文不会把每种表都列出来（如优先级、关键字等），这些网上或课本上都有，请自行翻阅，本书仅仅是讲清原理与我自己理解的逻辑。<br />
</p>

<p>
本文只把基础的逻辑与用法讲清楚，最后可能会附带几个例题，想要真正的学会编程还是要多写代码。<br />
</p>

<p>
如果对更加细节的部分感兴趣，可以看看这些：<a href="https://www.runoob.com/cprogramming/c-tutorial.html">C 语言教程</a>、<a href="https://github.com/jobbole/awesome-c-cn">awesome-c-cn</a><br />
</p>

<p>
最后请看看这篇文章《<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md">提问的智慧</a>》，问问题时请按照这上面做。<br />
</p>
</div>
</div>

<div id="outline-container-org2391229" class="outline-2">
<h2 id="org2391229">C语言</h2>
<div class="outline-text-2" id="text-org2391229">
</div>
<div id="outline-container-org723908f" class="outline-3">
<h3 id="org723908f">编程与运行流程</h3>
<div class="outline-text-3" id="text-org723908f">
</div>
<div id="outline-container-org27c8f00" class="outline-4">
<h4 id="org27c8f00">写代码</h4>
<div class="outline-text-4" id="text-org27c8f00">
<p>
对于 <code>windows</code> 来说，我推荐新手使用 <code>Dev-C++</code> 这个 <code>IDE</code> 来编写代码，这个软件虽然有些年头了，也很长时间没有更新了，但作为一个编程集成环境还是及格的，具体的操作还是比较简单，很多事情都能一键完成。<br />
对于参加蓝桥杯的同学， <code>Dev-C++</code> 也是官方指定的编程环境。<br />
请不要使用 <code>vc++</code> ！！！<br />
</p>

<p>
对于 <code>Linux</code> 来说，新手可以使用 <code>nano</code> 来编写代码，有基础的同学可以学下 <code>vim</code> ，进阶的话可以玩玩 <code>Emacs</code> 。<br />
</p>
</div>
</div>
<div id="outline-container-org04fd59b" class="outline-4">
<h4 id="org04fd59b">编译</h4>
<div class="outline-text-4" id="text-org04fd59b">
<p>
对于 <code>IDE</code> 来说只需要按下按钮就能自动的编译了，没有什么需要动脑的地方。<br />
</p>

<p>
当然我们不能这样就行了，下面简单介绍下编译是什么。我们写的代码其实都是文本文件，计算机并不认识，计算机只能处理2进制的指令，也就是机器语言，每种 <code>CPU</code> 的机器语言都是不一样的，所以我们需要把我们认识的代码转换成计算机认识机器代码，这个过程叫做编译。<br />
</p>

<p>
目前使用最广的编译器是 <code>gcc</code> ， <code>Dev-C++</code> 也是使用的这个编译器，安装 <code>gcc</code> 后可以在命令行使用 <code>gcc</code> 命令，这个命令给定一个源代码文件，然后输出一个二进制文件，然后计算机就能执行这个二进制文件了。<br />
</p>
</div>
</div>
<div id="outline-container-org37bef0c" class="outline-4">
<h4 id="org37bef0c">运行过程</h4>
<div class="outline-text-4" id="text-org37bef0c">
<div class="org-src-container">
<pre class="src src-c">#include &lt;stdio.h&gt;

int main() {
  printf("Hello, World\n");
  return 0;
}
</pre>
</div>

<p>
对于 <code>C</code> 来说，它运行时总会从 <code>main</code> 函数开始，只要 <code>main</code> 函数结束整个程序就结束了。对于上面这个代码来说，它输出了一行 <code>Hello，World</code> 文本，并返回了0。需要注意这个0是返回给了操作系统，作用只有一个，就是告诉操作系统这个程序运行过程是否有错误，0表示没有错误。<br />
</p>

<p>
注意 <code>main</code> 只是第一个执行的函数，定义语句、引入库函数语句、宏语句等肯定是要优先执行的。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org7a11518" class="outline-3">
<h3 id="org7a11518">语法简介</h3>
<div class="outline-text-3" id="text-org7a11518">
<p>
我们从简单的语句开始，语句由表达式组成，一条语句必须有一个分号当作结尾，比如 <code>1+1;</code> 就是一条语句。这条语句中的 <code>+</code> 是 <code>C</code> 自带的一些操作符，数学上常用的运算符都有。这里需要强调一下 <code>=</code> 是赋值运算符，比如 <code>a=b;</code> 的意思就是把a的值设置成b的值，也即对等号右边的表达式进行求值，然后把返回值赋值给左边。变量可以简单理解为一个箱子，箱子可以放置或取出数据。<br />
</p>

<p>
下面讲解表达式，每个表达式都有返回值，同一时刻只能运算一个操作。对于 <code>1+1+1</code> 这个表达式，它的求值过程是这样的：<br />
</p>
<ol class="org-ol">
<li>先运算第一个 <code>1+1</code> ，它的返回值是 <code>2</code><br /></li>
<li>表达式变成 <code>2+1</code><br /></li>
<li>得出返回值 <code>3</code><br /></li>
</ol>

<p>
记住分辩操作是跟根据操作符来的，有些操作符是需要两边都有数据，有些只需要一个，并且每个操作符都有优先级的，计算机会优先执行优先级高的操作，优先级一般来说符合直觉<br />
如果是同级的操作，根据操作符的类型来判定是从左到右还是从右到左。<br />
如果记不住执行的顺序，可以简单的使用括号把你想要独立执行的操作括起来，括号内的会优先执行。<br />
比如 <code>(1 + 2) * 3</code> -&gt; <code>(3) * 3</code> -&gt; <code>3 * 3</code> -&gt; <code>9</code><br />
</p>

<p>
这样就是最基本的 <code>C</code> 语法，更加复杂的语法在后面讲解。<br />
</p>
</div>
</div>
<div id="outline-container-orgb1a85b5" class="outline-3">
<h3 id="orgb1a85b5">变量</h3>
<div class="outline-text-3" id="text-orgb1a85b5">
</div>
<div id="outline-container-orgf0e03f8" class="outline-4">
<h4 id="orgf0e03f8">简介</h4>
<div class="outline-text-4" id="text-orgf0e03f8">
<p>
变量可以理解成一个箱子，我们可以把一些东西放到箱子，也可以从箱子内把东西取出来。<br />
类型的作用只是为每个箱子打上了标签，规定了箱子内不能随便放东西，比如一个放水果的箱子就不能把水倒进去。<br />
</p>
</div>
</div>
<div id="outline-container-org4cd1132" class="outline-4">
<h4 id="org4cd1132">类型</h4>
<div class="outline-text-4" id="text-org4cd1132">
<p>
<code>C</code> 是一个强类型的语言，它的意思就是每个数据都有类型，不同类型的数据不能随便使用，比如一个整数类型的变量就不能放入一个小数数据。<br />
</p>

<p>
<code>C</code> 里有三种简单常用的类型：整数、小数、字符；<br />
</p>

<p>
我们需要记下这些类型的名称<br />
整数有： <code>short</code> 、 <code>int</code> 、 <code>long</code> 、 <code>long long</code><br />
小数有： <code>float</code> 、 <code>doubel</code><br />
字符有： <code>char</code><br />
</p>

<p>
这些不同的类型之间的区别只是它们用来存储数据的空间大小，比如 <code>short</code> 只用2个字节存储整数。<br />
对于初学者只需要记下 <code>int</code> 、 <code>float</code>  、 <code>char</code> 就行了。<br />
</p>
</div>
</div>

<div id="outline-container-org45a128e" class="outline-4">
<h4 id="org45a128e">创建</h4>
<div class="outline-text-4" id="text-org45a128e">
<p>
创建一个变量需要使用变量声明语句，大概是这种形式 <code>&lt;变量类型&gt; &lt;变量名&gt;;</code> ，举个例子 <code>int a;</code> 这样就创建了一个 <code>int</code> 类型的变量 <code>a</code> 。<br />
</p>

<p>
如果使用这种形式 <code>&lt;变量类型&gt; &lt;变量名&gt; = &lt;表达式&gt;;</code> 的语句声明变量的话，就会给这个变量一个初始值，比如 <code>float pi = 3.1415926;</code> 就定义了一个 <code>float</code> 类型的变量 <code>pi</code> ，它的初始值为 <code>3.1415926</code> 。<br />
</p>

<p>
注意一点，变量名不能与 <code>C</code> 的关键字重名，已经使用过的名字不能重复定义。<br />
</p>
</div>
</div>
<div id="outline-container-org7c7dbd7" class="outline-4">
<h4 id="org7c7dbd7">使用</h4>
<div class="outline-text-4" id="text-org7c7dbd7">
<p>
在表达式内，我们可以把变量当作一个求值操作，这个操作的返回值为变量内的值，比如 <code>int a = 1;</code> 后 <code>a</code> 这个表示式的值就为 <code>1</code> ， <code>(a + 1) * a</code> -&gt; <code>(1 + 1) * a</code> -&gt; <code>2 * a</code> -&gt; <code>2 * 1</code> -&gt; <code>2</code> 。<br />
</p>

<p>
对于变量我们还可以对它使用赋值运算符，比如 <code>=</code> 、 <code>++</code> 、 <code>--</code> <br />
<code>=</code> 就是简单的把等号右边的表示式求值，放到等号左边的变量内<br />
<code>++</code> 是把变量内的值加上1，然后放到变量内<br />
<code>--</code> 是把变量内的值减去1，然后放入变量内<br />
</p>

<p>
赋值运算也是一个表示式，这意味着它也会返回一个值<br />
比如 <code>1 + (a = 3)</code> -&gt; <code>1 + 3</code> -&gt; <code>4</code><br />
需要注意这个表示式会有一个副作用，它把 <code>a</code> 的值改变成 <code>3</code> 了<br />
</p>

<p>
后面两个运算符有些许的复杂<br />
<code>a++</code> 的返回值是 <code>a</code><br />
<code>++a</code> 的返回值是 <code>a+1</code><br />
<code>a--</code> 的返回值是 <code>a--</code><br />
<code>--a</code> 的返回值是 <code>a-1</code><br />
注意，虽然返回值不一样，但这个变量的值都改变了，也即是一个副作用<br />
</p>

<p>
下面举些例子 <code>int a = 1;</code><br />
<code>1 + a++</code> -&gt; <code>1 + 1</code> -&gt; <code>2</code><br />
<code>a</code> -&gt; <code>2</code><br />
<code>1 + (++a)</code> -&gt; <code>1 + 3</code> -&gt; <code>4</code><br />
<code>a</code> -&gt; <code>3</code><br />
<code>1 + a--</code> -&gt; <code>1 + 3</code> -&gt; <code>4</code><br />
<code>a</code> -&gt; <code>2</code><br />
<code>1 + (--a)</code> -&gt; <code>1 + 1</code> -&gt; <code>2</code><br />
<code>a</code> -&gt; <code>1</code><br />
</p>

<p>
变量不能放入不同类型的数据，但把小数放到整数的盒子里肯定是常见的操作，这种不同类型的数据之间的操作 <code>C</code> 是支持。 <code>C</code> 会对不同类型的数据自动进行类型转换，转换的规则是尽量减少信息的流失，比如 <code>short</code> 和 <code>int</code> 类型的数据运算，返回的结果是 <code>int</code> 类型的数据。小数转换成整数会直接把小数部分去掉，并不会四舍五入。<br />
对于赋值运行也是相同的道理<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org8e9f29e" class="outline-3">
<h3 id="org8e9f29e">输入输出</h3>
<div class="outline-text-3" id="text-org8e9f29e">
</div>
<div id="outline-container-org600cae8" class="outline-4">
<h4 id="org600cae8">简介</h4>
<div class="outline-text-4" id="text-org600cae8">
<p>
我们写一个程序，一般都是面向用户的，作为人类我们肯定是需要获取和输入一些信息，一个无法干涉无法感知的东西我们是不能使用的。<br />
</p>

<p>
下面我就介绍下 <code>C</code> 里的标准输入输出，标准输入输出可以理解成通用的接口，一般情况下我们都可以使用这个接口来输入输出信息。<br />
一般情况输入输出都是文本的形式。<br />
</p>

<p>
需要注意 <code>C</code> 默认不包含输入输出的功能，我们需要引入这些功能， <code>stdio.h</code> 这个头文件包含了我们需要的功能，使用 <code>#include &lt;stdio.h&gt;</code> 这个命令我们可以引入它。<br />
可以简单的把这个命令理解成把 <code>stdio.h</code> 这个文件里的内容放到我们程序的最前面。<br />
</p>

<p>
函数也可以理解成一个魔法盒子，它可以放入一些数据，然后扔出一些数据。<br />
</p>
</div>
</div>

<div id="outline-container-org78942a1" class="outline-4">
<h4 id="org78942a1">输出</h4>
<div class="outline-text-4" id="text-org78942a1">
</div>
<ul class="org-ul">
<li><a id="org75495e3"></a>putchar<br />
<div class="outline-text-5" id="text-org75495e3">
<p>
这个函数很容易理解，传入一个字符，并把它输出， <code>c</code> 可以使用 <code>''</code> 包裹一个字符来表示一个字符常量，如果 <code>''</code> 内有多个字符就会报错。<br />
</p>

<p>
<code>putchar('a')</code> 语句输出 <code>a</code> 到标准输出。<br />
</p>
</div>
</li>
<li><a id="org5dfba8b"></a>puts<br />
<div class="outline-text-5" id="text-org5dfba8b">
<p>
同理这个函数也是传入一个字符串，并输出它，与字符的表示方式相似，我们使用 <code>""</code> 包裹多个字符来表示字符串变量。<br />
</p>

<p>
比如 <code>puts("Hello")</code> 语句就会输出 <code>Hello</code> 到标准输出。<br />
</p>
</div>
</li>
<li><a id="orgca01c1b"></a>printf<br />
<div class="outline-text-5" id="text-orgca01c1b">
<p>
格式化输出一串字符，它接收任意多个参数，第一个参数是一个字符串，并把它作为模板，里面可以放一些标识来表示需要把标识替换成我们想要的数据，后面的参数填入表达式，函数会按顺序把它们一个个填入模板字符串中。<br />
</p>

<div class="org-src-container">
<pre class="src src-c">#include &lt;stdio.h&gt;

int main() {
  /* 语句后面的注释里放输出的内容 */
  /* \n是转义字符，表示换行，因为有些字符不可输入 */
  printf("%d is a number\n", 123); /* 123 is a number */
  printf("%s is a string, and i like %c", "haha", 'a');/* haha is a string, and i like a */
  return 0;
}
</pre>
</div>
</div>
</li>
</ul>
</div>

<div id="outline-container-orgb9a6e1a" class="outline-4">
<h4 id="orgb9a6e1a">输入</h4>
<div class="outline-text-4" id="text-orgb9a6e1a">
</div>
<ul class="org-ul">
<li><a id="org86ec4f2"></a>getchar<br />
<div class="outline-text-5" id="text-org86ec4f2">
<p>
这个函数从标准输入读入一个字符然后返回，比如 <code>char c = getchar();</code> 这条语句就会从输入流获取一个字符，并赋值给变量 <code>c</code> 。<br />
</p>

<p>
<code>getchar</code> 只从输入拿下一个字符，所有的字符都可以拿下来，包括空白字符（空格、回车等等）<br />
</p>
</div>
</li>
<li><a id="org0374a38"></a>gets<br />
<div class="outline-text-5" id="text-org0374a38">
<p>
这个函数从标准输入读取一行字符，并把这一行填入一个字符数组。<br />
</p>

<div class="org-src-container">
<pre class="src src-c">#include &lt;stdio.h&gt;

int main() {
  char s[100];  /* 字符串可以理解成多个字符，所以c里面使用数组来表示字符串 */
  gets(s);      /* 与上面的getchar不同，它不会返回一个值 */
  puts(s);      /* 输出一个字符串 */
  return 0;
}
</pre>
</div>

<p>
请注意一行末尾的回车不会被填入字符数组。<br />
</p>
</div>
</li>
<li><a id="orgbe4a40d"></a>scanf<br />
<div class="outline-text-5" id="text-orgbe4a40d">
<p>
这个函数就可以支持多种形式格式的输入了，与上面的 <code>printf</code> 有相同的控制符。<br />
需要注意一点， <code>scanf</code> 填写变量的位置需要提供一个指针，获取变量指针的方法是使用 <code>&amp;</code> 运算符。<br />
使用 <code>%c</code> 时和 <code>getchar</code> 一样会读取空白字符<br />
使用 <code>%s</code> 时只要遇到一个空白字符就会停止<br />
</p>

<div class="org-src-container">
<pre class="src src-c">#include &lt;stdio.h&gt;

int main() {
  int n;
  char s[100];
  /* n是一个变量需要使用 &amp; 获取它的指针
   * 而数组名就是一个指针 */
  scanf("%d %s", &amp;n, s);
  printf("%d %s\n", n, s);
  return 0;
}
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgebe21c8" class="outline-3">
<h3 id="orgebe21c8">选择</h3>
<div class="outline-text-3" id="text-orgebe21c8">
</div>
<div id="outline-container-org5ddafc6" class="outline-4">
<h4 id="org5ddafc6">简介</h4>
<div class="outline-text-4" id="text-org5ddafc6">
<p>
选择结构的出现打破了我之前讲述的简洁明了的语法，我们需要重新学习一些额外的情况，所幸这种新结构并不复杂。<br />
</p>

<p>
选择结构有三种表达方式， <code>if</code> 、 <code>switch</code> 、 <code>三元运算符</code><br />
前面两种方式可以相互转换，而最后一种出现的目的是减少代码行数，同时也加重了我们理解程序的负担。<br />
</p>

<p>
需要注意一点，在选择结构内如果执行了 <code>break</code> 会直接结束当前的选择结构。<br />
</p>
</div>
</div>
<div id="outline-container-orga0ac063" class="outline-4">
<h4 id="orga0ac063">if</h4>
<div class="outline-text-4" id="text-orga0ac063">
<p>
它的语法大概是这样 <code>if (表达式) { 代码块 }</code><br />
简单来说如果对表达式求值的结果为真，就执行使用 <code>{}</code> 包裹的代码块<br />
<code>c</code> 里面使用 <code>0</code> 表示假，而其它的任何值都为真<br />
所谓代码块就是任意行语句<br />
</p>

<p>
如果需要执行的语句只有一行可以使用 <code>if (表达式-判断) 表达式-执行;</code> 的形式，表达式可以不写。<br />
</p>

<p>
如果我们还要对表达式为假的情况做些操作，并不用再写一个 <code>if</code> ，可以使用下述方式<br />
<code>if (表达式) {为真时执行} else {为假时执行}</code><br />
同理，只有一条语句时可以省略 <code>{}</code><br />
下面看一个例子<br />
</p>

<div class="org-src-container">
<pre class="src src-c">#include &lt;stdio.h&gt;

int main() {
  int a = 10;
  if (a &lt; 20)
    puts("a &lt; 20\n");
  
  if (a &gt; 100)
    puts("a &gt; 100");
  else
    puts("a &lt;= 100");

  if (a &gt; 10)
    puts("a &gt; 10\n");
  else if (a &lt; 10)
    puts("a &lt; 10\n");
  else
    puts("a == 10\n");
  return 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org514809f" class="outline-4">
<h4 id="org514809f">switch</h4>
<div class="outline-text-4" id="text-org514809f">
<p>
<code>switch</code> 的语法比较复杂，简单来说它会把你给予的一个整数与 <code>case</code> 语句从上到下一一比对<br />
如果跟 <code>case</code> 语句后面的值相等，就执行 <code>case</code> 对应的代码块<br />
<code>default</code> 表示没有一个 <code>case</code> 语句匹配时的情况<br />
</p>

<div class="org-src-container">
<pre class="src src-c">#include &lt;stdio.h&gt;

int main() {
  switch(10) {
    case 10:
      puts("10");
    case 9:
      puts("9");
    default:
      puts("not match");
  }
  return 0;
}
</pre>
</div>

<p>
需要注意，有匹配项后它会忽略当前 <code>case</code> 后面的所有 <code>case</code> 条件，即它会执行匹配 <code>case</code> 后面的所有语句，直到 <code>switch</code> 结构结束。<br />
所以我们一般对于每个 <code>case</code> 都会在它的结尾加上 <code>break</code><br />
</p>
</div>
</div>
<div id="outline-container-org3898866" class="outline-4">
<h4 id="org3898866">三元运算符</h4>
<div class="outline-text-4" id="text-org3898866">
<p>
它的语法比较简单 <code>条件?表达式1:表达式2</code><br />
对这个三元运算表达式求值时，如果条件为真就执行并返回表达式1的值，否则执行并返回表达式2的值<br />
</p>

<div class="org-src-container">
<pre class="src src-c">#include &lt;stdio.h&gt;

int main() {
  int a, b;
  scanf("%d %d", &amp;a, &amp;b);
  printf("the max number is:%d\n", a &gt; b ? a : b);
  return 0;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org0afdb40" class="outline-3">
<h3 id="org0afdb40">循环</h3>
<div class="outline-text-3" id="text-org0afdb40">
</div>
<div id="outline-container-org27abb30" class="outline-4">
<h4 id="org27abb30">简介</h4>
<div class="outline-text-4" id="text-org27abb30">
<p>
我们继续来破坏 <code>c</code> 的简单性，这次介绍循环结构<br />
有两种方式来描述一个循环结构 <code>while</code> 、 <code>for</code><br />
</p>
</div>
</div>
<div id="outline-container-org90d4187" class="outline-4">
<h4 id="org90d4187">while</h4>
<div class="outline-text-4" id="text-org90d4187">
<p>
语法为 <code>while(条件) {代码块}</code><br />
与 <code>if</code> 的结构相似，与 <code>if</code> 不同的地方在于， <code>while</code> 会在代码块执行结束后重复检查条件，如果条件还是为真就继续执行代码块<br />
简单来说就是执行代码块直到条件为假。<br />
</p>

<div class="org-src-container">
<pre class="src src-c">#include &lt;stdio.h&gt;

int main() {
  int a = 10, sum = 0;
  while (a &gt; 0) {
    sum += a;
    a--;
  }
  printf("%d\n", sum);
  return 0;
}
</pre>
</div>

<p>
<code>while</code> 还有一种变形 <code>do while</code> ，它的语法为<br />
<code>do {代码块} while(条件);</code><br />
与 <code>while</code> 的差别就是它一定会执行一次代码块<br />
</p>
</div>
</div>
<div id="outline-container-org6cdc260" class="outline-4">
<h4 id="org6cdc260">for</h4>
<div class="outline-text-4" id="text-org6cdc260">
<p>
语法为： <code>for (初始化;条件;副作用){代码块}</code><br />
<code>for</code> 可以转换成 <code>while</code> 的形式<br />
<code>初始化;while(条件){代码块;副作用;}</code><br />
初始化部分会在代码块之前执行，并且只执行一次<br />
每次条件为真时会执行代码块<br />
而副作用部分会在每次代码块结束后执行<br />
</p>

<p>
<code>for</code> 可以理解成 <code>while</code> 的严格模式，它让你把一些容易忘记写的部分先写好，尽量避免出错的可能性，比如写 <code>while</code> 语句时有人可能就忘记在末尾加上递增语句了。<br />
</p>

<div class="org-src-container">
<pre class="src src-c">#include &lt;stdio.h&gt;

int main() {
  int a = 10, sum = 0;
  for (a = 10; a &gt; 0; a--) {
    sum += a;
  }
  printf("%d\n", sum);
  return 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf9a1339" class="outline-3">
<h3 id="orgf9a1339">数组</h3>
<div class="outline-text-3" id="text-orgf9a1339">
</div>
<div id="outline-container-orgf2643ec" class="outline-4">
<h4 id="orgf2643ec">简介</h4>
<div class="outline-text-4" id="text-orgf2643ec">
<p>
数组提供了简单声明多个变量的方法，假设你需要对100个数进行排序，如果采用以往声明变量的方式，你需要写100个变量名，而使用数组就能一行语句生成多个变量。<br />
</p>
</div>
</div>
<div id="outline-container-orgf9c44c4" class="outline-4">
<h4 id="orgf9c44c4">语法</h4>
<div class="outline-text-4" id="text-orgf9c44c4">
<p>
数组的语法非常简单 <code>类型名 数组名[数组大小]</code><br />
类型名和数组名与变量的声明相同，数组与变量的区别只在于后面的那个括号，括号定义了数组里包含多少个元素，使用 <code>数组名[下标]</code> 可以找到任意一个元素，而它的使用方式与普通变量并无区别<br />
声明数组后，数组的大小不可改变，如果下标超过声明的大小，程序可能会发生错误<br />
既然声明后不可改变大小，而一次想好数组大小是一件很头疼的事情，那么可以不可以让数组的大小跟随数据变化呢？<br />
比如我知道了有100个数据，那么我只用开一个长度为100的数组即可<br />
对于 <code>vc++</code> 这些使用低版本编译器的 <code>IDE</code> 来说这是不可行的，因为低版本的编译器 <code>[]</code> 内只能放常量<br />
但如果你使用 <code>Dev-C++</code> 的话就不用但这个问题，它是可以在 <code>[]</code> 内放表达式的<br />
</p>

<p>
注意第一个元素的下标为0<br />
</p>

<p>
我们对于 <code>类型名 数组名[行数][列数]</code> 这种形式的数组称为二维数组，同理我们能够声明任意维度的数组<br />
对于二维数组，使用它时必须填好两个 <code>[]</code> 内的内容，你可以简单画一个表格，这样方便理解<br />
</p>
</div>
</div>
<div id="outline-container-org848a286" class="outline-4">
<h4 id="org848a286">插入排序</h4>
<div class="outline-text-4" id="text-org848a286">
<div class="org-src-container">
<pre class="src src-c">#include &lt;stdio.h&gt;

int main() {
  int len, i, j;
  scanf("%d", &amp;len);        /* 输入数组长度 */
  int arr[len];             /* 动态定义数组 */
  for (i = 0; i &lt; len; i++) /* 输入数据 */
    scanf("%d", arr + i);

  /* 使用插入排序，下面介绍一下原理
   * 简单来说对于每个i，找到i后面最小的元素，并让它与i位置的元素交换
   * 也既保持每个i上的元素都比之后的元素小 */
  for (i = 0; i &lt; len; i++)
    for (j = i + 1; j &lt; len; j++)
      if (arr[i] &gt; arr[j]) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
      }

  /* 输出数据 */
  for (i = 0; i &lt; len; i++)
    printf("%d ", arr[i]);
  printf("\n");
  return 0;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orga3c7b8e" class="outline-3">
<h3 id="orga3c7b8e">指针</h3>
<div class="outline-text-3" id="text-orga3c7b8e">
</div>
<div id="outline-container-org6896adb" class="outline-4">
<h4 id="org6896adb">简介</h4>
<div class="outline-text-4" id="text-org6896adb">
<p>
前面我们介绍了变量，变量我把它形容成一个盒子，盒子可以往里面放或拿东西<br />
现在想像一下，我们把所有的盒子都放到地上，按顺序一个一个编号<br />
如果有人想用盒子就标记一下这个盒子被占用了，并自己记下盒子的编号，然后就可以自由使用这个盒子了<br />
这个编号我们就称之为地址，而指针也是一个盒子，但它里面装着的东西只能是地址，也即一个地址类型的变量<br />
或者可以想像成一个里面放着纸条的盒子，纸条上写着一个盒子的地址<br />
</p>
</div>
</div>
<div id="outline-container-org22e0e10" class="outline-4">
<h4 id="org22e0e10">语法</h4>
<div class="outline-text-4" id="text-org22e0e10">
<p>
<code>类型 *指针名</code> 就可以声明一个指针了<br />
需要注意一下 <code>int* a, b</code> 并不会声明指针 <code>a</code> <code>b</code> ，而是声明一个指针 <code>a</code> 与一个变量 <code>b</code><br />
所以写代码时请让 <code>*</code> 挨着指针名<br />
</p>
</div>
</div>
<div id="outline-container-orgfc16ad5" class="outline-4">
<h4 id="orgfc16ad5">用法</h4>
<div class="outline-text-4" id="text-orgfc16ad5">
<p>
指针可以放地址，但是我们怎么获得一个地址呢？<br />
有些同学可能已经想到了，我们之前用 <code>scanf</code> 的时候使用一个操作符 <code>&amp;</code><br />
使用 <code>&amp;变量</code> 的方式，我们就能获得变量的地址了<br />
但我们对指针求值得到的结果是一个地址，那么我们怎么使用指针指向的变量呢？<br />
很简单，我们可以使用 <code>*指针</code> 的方式来找到那个地址<br />
通俗来说，跟着盒子内的纸条找到另一个盒子<br />
<code>*指针</code> 和普通变量的用法是一样的<br />
</p>
</div>
</div>
<div id="outline-container-org75fc66e" class="outline-4">
<h4 id="org75fc66e">数组</h4>
<div class="outline-text-4" id="text-org75fc66e">
<p>
对于数组来说，数组名其实是一个指针，它保存的是数组的起始地址<br />
我们先定义一个数组 <code>int arr[10]</code><br />
我们可以发现 <code>arr[2]</code> 和 <code>*(arr+2)</code> 的效果是一样的，其实 <code>arr[2]</code> 是一个<a href="https://baike.baidu.com/item/%E8%AF%AD%E6%B3%95%E7%B3%96">语法糖</a><br />
<code>arr+2</code> 的意思就是找到 <code>arr</code> 之后两个位置的地址<br />
需要注意指针会自动识别一个单元格的大小<br />
</p>

<p>
还记得之前我们说过 <code>vc++</code> 不能动态定义数组长度吗？<br />
现在我们通过指针来实现这一功能<br />
首先先引入 <code>stdlib.h</code> 库，我们要使用 <code>malloc</code> 函数，这个函数可以让我们向系统申请内存，也就是和盒子的例子一样，我们登记一个盒子<br />
然后这样 <code>int *arr = (int *)malloc(sizeof(int) * len)</code> 就可以定义一个len长度的数组了<br />
</p>

<div class="org-src-container">
<pre class="src src-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
  int len, i, j;
  scanf("%d", &amp;len);                           /* 输入数组长度 */
  int *arr = (int *)malloc(sizeof(int) * len); /* 动态定义数组 */
  for (i = 0; i &lt; len; i++)                    /* 输入数据 */
    scanf("%d", arr + i);

  /* 使用插入排序，下面介绍一下原理
   * 简单来说对于每个i，找到i后面最小的元素，并让它与i位置的元素交换
   * 也既保持每个i上的元素都比之后的元素小 */
  for (i = 0; i &lt; len; i++)
    for (j = i + 1; j &lt; len; j++)
      if (arr[i] &gt; arr[j]) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
      }

  /* 输出数据 */
  for (i = 0; i &lt; len; i++)
    printf("%d ", arr[i]);
  printf("\n");
  return 0;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org4b80d3e" class="outline-3">
<h3 id="org4b80d3e">函数</h3>
<div class="outline-text-3" id="text-org4b80d3e">
</div>
<div id="outline-container-org2eade7a" class="outline-4">
<h4 id="org2eade7a">简介</h4>
<div class="outline-text-4" id="text-org2eade7a">
<p>
函数让我们可以把一堆操作封装起来，下次可以直接使用，数学一点的像pi、cos、sin等都可以用函数封装起来，再比如打印一行星号、对数组进行排序、计算fib数列之类的。<br />
</p>

<p>
如果你以后开发一个比较大型的应用，把所有语句写在 <code>main</code> 函数里当然也可以，但如果你突然发现一个功能写错了，那么你可以会痛苦的找上很久 <code>bug</code> 。<br />
而如果你模块化的把每个功能都封装好成一个个函数，那么你就能单独的测试每个函数，更妙的是如果你把每个函数的名字起的好，那么你的程序就可以像读文章一样，不需要注释也能读懂。<br />
</p>
</div>
</div>
<div id="outline-container-org351d603" class="outline-4">
<h4 id="org351d603">语法</h4>
<div class="outline-text-4" id="text-org351d603">
<p>
<code>返回类型 函数名(类型1 参数1，类型2 参数2){函数体}</code> 就可以创建一个函数<br />
每个函数都要定义好返回类型，函数可以有多个参数，每个参数都必须定义类型，因为 <code>c</code> 是强类型的语言<br />
变量进入函数时，函数并不会使用原来的变量，而是把变量里的内容复制到一个新建的变量，记住这一点！！！<br />
函数只能有一个返回值，那么我想返回多个值怎么办呢？<br />
我们可以返回一个结构体<br />
</p>
</div>
</div>
<div id="outline-container-orgdb3cad7" class="outline-4">
<h4 id="orgdb3cad7">例子</h4>
<div class="outline-text-4" id="text-orgdb3cad7">
<p>
我们来简单的举一个例子，交换变量里的值<br />
我们先看看错误的例子<br />
</p>

<div class="org-src-container">
<pre class="src src-c">#include &lt;stdio.h&gt;

void swap(int a, int b) {
  int temp = a;
  a = b;
  b = temp;
}

int main() {
  int a, b;
  scanf("%d %d", &amp;a, &amp;b);
  swap(a, b);
  printf("%d %d\n", a, b);
  return 0;
}
</pre>
</div>

<p>
对于这个例子，它的关键点是 <code>swap</code> 函数，为什么在函数里已经交换了变量，但输出的结果却和输入一样呢？<br />
原因已经在语法里说过，函数内的变量并不是从函数外进入的变量，函数内的变量只是复制了他的值，所以你无论在函数内做什么操作，都不会影响到函数外的变量。<br />
那我们怎么办呢？<br />
现在又到指针登场的环节了<br />
</p>

<div class="org-src-container">
<pre class="src src-c">#include &lt;stdio.h&gt;

void swap(int *a, int *b) {
  int temp = *a;
  *a = *b;
  *b = temp;
}

int main() {
  int a, b;
  scanf("%d %d", &amp;a, &amp;b);
  swap(&amp;a, &amp;b);
  printf("%d %d\n", a, b);
  return 0;
}
</pre>
</div>

<p>
可以看到我把两个指针作为参数，然后我把 <code>a</code> <code>b</code> 的地址传入了函数，这样虽然只把值复制了过去，但我们已经知识了地址，所以直接修改地址指针的内存即可。<br />
</p>
</div>
</div>
</div>

<div id="outline-container-org8f15a6d" class="outline-3">
<h3 id="org8f15a6d">递归</h3>
<div class="outline-text-3" id="text-org8f15a6d">
</div>
<div id="outline-container-orgc9ee58e" class="outline-4">
<h4 id="orgc9ee58e">简介</h4>
<div class="outline-text-4" id="text-orgc9ee58e">
<p>
首先，我们可以确定一点，函数内是可以使用函数的，这点一开始就可以从在 <code>main</code> 函数内使用 <code>printf</code> 看出。<br />
那么你有没有想过，如果我在函数内使用自己会怎么样呢？<br />
可以预见，没有特殊措施的话，程序会疯狂的循环<br />
但只要函数有最小值，并且每次递归时输入的规模都会减少，这个函数还是会停止的<br />
</p>
</div>
</div>
<div id="outline-container-orga1fad5b" class="outline-4">
<h4 id="orga1fad5b">fib</h4>
<div class="outline-text-4" id="text-orga1fad5b">
<p>
对于fib数列，它在数学是这样定义的<br />
</p>
\begin{equation}
fib(n)=\left\{
\begin{array}{cc}
0 & {n=0}\\
1 & {n=1}\\
1 & {n=2}\\
fib(n-1)+fib(n-2) & {n>2}
\end{array}
\right.
\end{equation}

<p>
可以看到上面是 <code>fib</code> 函数的定义，我们只需要把它转换成 <code>c</code> 的形式即可<br />
</p>

<div class="org-src-container">
<pre class="src src-c">#include &lt;stdio.h&gt;

int fib(int n) {
  if (n == 0)
    return 0;
  if (n &lt; 2)
    return 1;
  return fib(n - 1) + fib(n - 2);
}

int main() {
  int n;
  scanf("%d", &amp;n);
  printf("%d\n", fib(n));
  return 0;
}
</pre>
</div>

<p>
从这个例子可以看出对于数学上的东西，使用递归是最好写的，但这也说明了，理解需要一定的数学思维，毕竟现实世界上人可不能把自己提起来。<br />
</p>

<p>
为什么函数自己调用自己时不会产生混乱呢？<br />
因为 <code>c</code> 每次执行函数时，都是新生成了一个机器。如果我们把函数定义比做一张蓝图，那么执行函数时我们就制作了一个机器来运行，也就是每次执行的函数都是一个全新的机器，我在这台机器做的操作当然不会同步到另一台机器，而之前的一台机器也会耐心等待后面的机器运行完毕后，再把返回的结果拿过来。<br />
</p>
</div>
</div>
</div>

<div id="outline-container-orgf2900f6" class="outline-3">
<h3 id="orgf2900f6">结构体</h3>
<div class="outline-text-3" id="text-orgf2900f6">
</div>
<div id="outline-container-org900ba0b" class="outline-4">
<h4 id="org900ba0b">简介</h4>
<div class="outline-text-4" id="text-org900ba0b">
<p>
结构体提供了一个把多种类型，多个变量集合到一起的功能<br />
比如我想保存一个学生的数据，对于学生他有年龄、名字、学号、性别...<br />
我们当然可以直接定义多个变量，但如果我想把这些数据传入函数处理，那么就要输入很多变量，而如果我想返回一个学生的数据，那我们只能使用丑陋又危险的全局变量了<br />
或者，我们可以简单的使用结构体来解决这些问题<br />
</p>
</div>
</div>
<div id="outline-container-org1b7a733" class="outline-4">
<h4 id="org1b7a733">语法</h4>
<div class="outline-text-4" id="text-org1b7a733">
<p>
结构体其实是声明了一个类型，很奇怪吧，我们之前声明过很多东西，但没想到类型也可以自定义吧<br />
类型就意味着，使用结构体时，我们是使用一个结构体类型的变量<br />
下面我们就直接来看代码<br />
</p>

<div class="org-src-container">
<pre class="src src-c">#include &lt;stdio.h&gt;

/* 定义了一个结构体类型stu */
struct stu {
  /* 学号和年龄 */
  int no, age;
  /* 性别和名字 */
  char sex, name[20];
};

void prtstu(struct stu a) {
  printf("学号：%d 年龄：%d 性别：%c 名字：%s\n", a.no, a.age, a.sex, a.name);
}

int main() {
  /* struct表示它是一个结构体类型 */
  struct stu xiami;
  /* 使用.运算符可以使用结构体内的变量 */
  scanf("%d %d %c %s", &amp;xiami.no, &amp;xiami.age, &amp;xiami.sex, xiami.name);
  prtstu(xiami);
  return 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb662b24" class="outline-4">
<h4 id="orgb662b24">结构体指针</h4>
<div class="outline-text-4" id="text-orgb662b24">
<p>
我们来看一个很魔鬼的东西，结构体指针<br />
顾名思义，结构体指针就是存放着结构体变量地址的变量<br />
使用 <code>struct stu *p</code> 就定义了一个学生类型的结构体指针， <code>p</code> 可以指向一个结构体变量的地址了<br />
现在我们再声明一个结构体变量 <code>struct stu a</code> ，把 <code>p</code> 指向这个变量 <code>p = &amp;a</code><br />
现在我们想知道a的年龄就可以这样 <code>(*p).age</code><br />
因为 <code>.</code> 的优先级高于 <code>*</code> 所以必须用一个括号括起来<br />
这个方式太过麻烦，跟不用 <code>[]</code> 的数组一样，那么官方有没有做一个对应的语法糖呢？<br />
幸运的是还真有，使用 <code>-&gt;</code> 即可， <code>p-&gt;ag</code> 就可以查看 <code>a</code> 的年龄了<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org07f255a" class="outline-2">
<h2 id="org07f255a">C++</h2>
<div class="outline-text-2" id="text-org07f255a">
</div>
<div id="outline-container-org8d59be3" class="outline-3">
<h3 id="org8d59be3">stl</h3>
<div class="outline-text-3" id="text-org8d59be3">
<p>
<code>c++</code> 是 <code>c</code> 的超集，也就是说 <code>c++</code> 支持所有 <code>c</code> 的语法，并在此基础上 <code>c++</code> 又新增了一些语法与工具。更重要的区别在于 <code>c</code> 是面向过程的，而 <code>c++</code> 是面向对象的。<br />
</p>

<p>
对于我们做算法竞赛的同学来说， <code>c++</code> 最重要的功能就是 <code>stl</code> 了，它内置了许多有用的工具，这使得我们不需要一切都从轮子写起。<br />
</p>

<p>
<code>namespace</code> 即命名空间，不同于 <code>c</code> 在 <code>c++</code> 里提供了一种分隔代码的好方法，我们可以为一类变量函数增加一个命名空间，使用 <code>空间名::变量名</code> 就可以使用这个命名空间内的东西， <code>stl</code> 就是这样做的，它为每个变量与函数都设置了名为 <code>std</code> 的命名空间。但这个东西其实非常的麻烦，每个函数我都要加上5个字符，所以可以使用 <code>using namespace std;</code> 来导入这个命名空间，让它所有的变量与函数暴露出来。<br />
</p>

<p>
但这也引出了一个问题， <code>std</code> 下的内容太多了，像 <code>min</code> 、 <code>max</code> 、 <code>next</code> 、 <code>count</code> 等等常用的名字都被使用了，所以我们必须避开他们，使用其它的名字。<br />
</p>
</div>
</div>
<div id="outline-container-org0365e9a" class="outline-3">
<h3 id="org0365e9a">输入输出</h3>
<div class="outline-text-3" id="text-org0365e9a">
</div>
<div id="outline-container-orgc230faf" class="outline-4">
<h4 id="orgc230faf">头文件</h4>
<div class="outline-text-4" id="text-orgc230faf">
<p>
<code>c++</code> 的输入输出头文件叫 <code>iostream</code> ，引用使用 <code>#include &lt;iostream&gt;</code> 语句<br />
</p>

<p>
可以发现，头文件后面并没有 <code>.h</code> ，这是 <code>c++</code> 与 <code>c</code> 的不同，所有新增的头文件都不能加 <code>.h</code><br />
</p>
</div>
</div>
<div id="outline-container-org47e84b4" class="outline-4">
<h4 id="org47e84b4">cin</h4>
<div class="outline-text-4" id="text-org47e84b4">
<p>
使用 <code>cin &gt;&gt; 变量名</code> 可以从标准输入把数据输入变量内，需要注意的是输入时不需要加标识符来表示变量的类型， <code>c++</code> 可以自己确定变量的类型，并根据类型自己确定会输入的数据。<br />
</p>

<p>
<code>cin &gt;&gt; 变量名1 &gt;&gt; 变量名2 &gt;&gt; 变量名3</code> 它的后面可以接许多个变量，变量的输入是从左至右依次进行， <code>&gt;&gt;</code> 可以把想像成数据流入了变量。<br />
</p>
</div>
</div>
<div id="outline-container-orgbd75d0b" class="outline-4">
<h4 id="orgbd75d0b">cout</h4>
<div class="outline-text-4" id="text-orgbd75d0b">
<p>
同理 <code>cout &lt;&lt; 表达式</code> 就可以向标准输出输出内容了， <code>cout</code> 也会自动判断表达式返回值的类型，但相比 <code>printf</code> 它就不能做到精准的格式输出了，比如固定4位宽度的数字使用 <code>cout</code> 就比较难以做到了。<br />
</p>
</div>
</div>
<div id="outline-container-orgb45682e" class="outline-4">
<h4 id="orgb45682e">总结</h4>
<div class="outline-text-4" id="text-orgb45682e">
<p>
对于输入没有规定必须使用哪个，挑选最合适的就行了。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgd05fe31" class="outline-3">
<h3 id="orgd05fe31">vector</h3>
<div class="outline-text-3" id="text-orgd05fe31">
</div>
<div id="outline-container-org5d86a23" class="outline-4">
<h4 id="org5d86a23">头文件</h4>
<div class="outline-text-4" id="text-org5d86a23">
<p>
<code>#include &lt;vector&gt;</code><br />
</p>
</div>
</div>
<div id="outline-container-org6df67ba" class="outline-4">
<h4 id="org6df67ba">简介</h4>
<div class="outline-text-4" id="text-org6df67ba">
<p>
<code>vector</code> 翻译成中文叫向量<br />
它可以理解成一个动态数组，它的长度可以自由调整<br />
</p>
</div>
</div>
<div id="outline-container-orgcebd33a" class="outline-4">
<h4 id="orgcebd33a">创建</h4>
<div class="outline-text-4" id="text-orgcebd33a">
<p>
<code>vector&lt;类型名&gt; 数组名</code> 就可以创建一个 <code>vector</code> 了<br />
不止如此， <code>vector</code> 支持初始化时自定义长度与初始内容<br />
<code>vector&lt;int&gt; v1(3)</code> 创建了长度为3，元素默认值为0的 <code>vector</code><br />
<code>vector&lt;int&gt; v2(5, 10)</code> 创建了长度为5，元素默认值为10的 <code>vector</code><br />
<code>vector&lt;int&gt; v3(v1)</code> 创建了和 <code>v1</code> 内容一样的 <code>vector</code><br />
</p>
</div>
</div>
<div id="outline-container-org3283bc1" class="outline-4">
<h4 id="org3283bc1">使用</h4>
<div class="outline-text-4" id="text-org3283bc1">
<p>
可以直接使用 <code>[]</code> 像数组一样访问 <code>vector</code><br />
<code>vector</code> 因为是一个对象，它内置了一系列函数，其中有一个名为 <code>at()</code> 的函数也可以访问对应下标的元素，但如果下标越界了它会直接抛出异常<br />
</p>

<p>
下面我介绍几个常用的函数：<br />
<code>size()</code> 返回向量的长度<br />
<code>empty()</code> 如果向量为空则返回真<br />
<code>begin()</code> 返回向量第一个元素的引用（地址）<br />
<code>end()</code> 返回向量最后一个元素之后一个长度的引用<br />
<code>push_back()</code> 在向量后面加入一个元素<br />
<code>pop_back()</code> 删除向量最后一个元素<br />
<code>insert()</code> 在某个位置插入元素<br />
</p>

<p>
<code>vector</code> 也重载了一些运算符<br />
使用 <code>v1=v2</code> 可以直接赋值<br />
使用 <code>v1==v2</code> 可以轻松的判断两个向量是否完全一致<br />
使用 <code>v1&gt;v2</code> 可以判断两个向量的大小问题，它从第一个元素开始对比，如果当前 <code>v1</code> 元素不等于 <code>v2</code> 直接返回它们之间的大小，如果相等就同时向后延一格对比<br />
</p>
</div>
</div>
</div>

<div id="outline-container-org2eaa8ee" class="outline-3">
<h3 id="org2eaa8ee">string</h3>
<div class="outline-text-3" id="text-org2eaa8ee">
</div>
<div id="outline-container-org1c05488" class="outline-4">
<h4 id="org1c05488">头文件</h4>
<div class="outline-text-4" id="text-org1c05488">
<p>
<code>#include &lt;string&gt;</code><br />
</p>
</div>
</div>
<div id="outline-container-orgd4db4c6" class="outline-4">
<h4 id="orgd4db4c6">简介</h4>
<div class="outline-text-4" id="text-orgd4db4c6">
<p>
<code>string</code> 是一个字符串，它的底层实现是 <code>vector</code> 它可以使用 <code>vector</code> 的所有函数，它也新加了许多方便的方法<br />
</p>
</div>
</div>
<div id="outline-container-org62b9640" class="outline-4">
<h4 id="org62b9640">使用</h4>
<div class="outline-text-4" id="text-org62b9640">
<p>
它的创建方法与 <code>vector</code> 一样，这些可以直接看上面的 <code>vector</code> 介绍<br />
</p>

<p>
对于字符串来说它有两个方法非常常用<br />
<code>find()</code> 可以查找子串第一次出现的位置，函数可以传入字符或字符串<br />
<code>substr(pos, len)</code> 从 <code>pos</code> 开始开始截取 <code>len</code> 个字符并返回它<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgff16d8f" class="outline-3">
<h3 id="orgff16d8f">queue</h3>
<div class="outline-text-3" id="text-orgff16d8f">
</div>
<div id="outline-container-orga431643" class="outline-4">
<h4 id="orga431643">头文件</h4>
<div class="outline-text-4" id="text-orga431643">
<p>
<code>#include &lt;queue&gt;</code><br />
</p>
</div>
</div>
<div id="outline-container-org4f56c91" class="outline-4">
<h4 id="org4f56c91">简介</h4>
<div class="outline-text-4" id="text-org4f56c91">
<p>
<code>queue</code> 叫做队列，它是一种数据结构，先进入队列的数据会先出来，可以想像一个管子，从后面往里面塞球，取球时只能从前面取<br />
</p>

<p>
还有一个叫双端队列的类 <code>deque</code> ，与 <code>queue</code> 的不同在于， <code>deque</code> 可以从两边取和删除数据<br />
</p>

<p>
为什么要使用队列呢？我使用数组也可以做到相同功能<br />
原因就是数组在前端插入一个数据需要遍历整个数组，但队列只需要一下操作就能实现，这在数据量大的情况下是有利的。<br />
简单来说 <code>queue</code> 的修改是 <code>O(1)</code> 的，而数组的修改是 <code>O(n)</code> 的。<br />
</p>
</div>
</div>
<div id="outline-container-org1ad2ba2" class="outline-4">
<h4 id="org1ad2ba2">使用</h4>
<div class="outline-text-4" id="text-org1ad2ba2">
<p>
<code>queue&lt;类型名&gt; 队列名</code> 就可以创建一个队列了，初始化的方法与之前的方法一致<br />
</p>

<p>
<code>queue</code> 的函数：<br />
<code>empty()</code> 返回队列是否为空<br />
<code>push()</code> 向队尾插入一个元素<br />
<code>pop()</code> 队首弹出一个元素<br />
<code>front()</code> 查看队首的元素<br />
</p>

<p>
<code>deque</code> 的函数：<br />
<code>push_front()</code> 在队首插入元素<br />
<code>pop_front()</code> 弹出队首的元素<br />
<code>push_back()</code> 在队尾插入元素<br />
<code>pop_back()</code> 弹出队尾的元素<br />
<code>at()</code> 通过下标访问元素<br />
</p>
</div>
</div>
</div>

<div id="outline-container-org23ed20e" class="outline-3">
<h3 id="org23ed20e">stack</h3>
<div class="outline-text-3" id="text-org23ed20e">
</div>
<div id="outline-container-org9a96ce5" class="outline-4">
<h4 id="org9a96ce5">头文件</h4>
<div class="outline-text-4" id="text-org9a96ce5">
<p>
<code>#include &lt;stack&gt;</code><br />
</p>
</div>
</div>
<div id="outline-container-orge8bfc8d" class="outline-4">
<h4 id="orge8bfc8d">简介</h4>
<div class="outline-text-4" id="text-orge8bfc8d">
<p>
<code>stack</code> 是栈，与队列相反，栈只能在一端插入或删除，就像一个筒装薯片一样，你可以在开口处拿薯片或放入薯片，可以发现栈的元素是后进先出的。<br />
</p>

<p>
我们的递归函数底层使用了栈，有时写算法题时直接使用递归可能会爆内存，这时可以使用栈来模拟递归。<br />
</p>
</div>
</div>
<div id="outline-container-org9e53b50" class="outline-4">
<h4 id="org9e53b50">使用</h4>
<div class="outline-text-4" id="text-org9e53b50">
<p>
<code>stack&lt;类型名&gt; 栈名</code> 与之前初始化一样的方法<br />
</p>

<p>
<code>stack</code> 的函数主要有：<br />
<code>back()</code> 获取尾部元素<br />
<code>push_back()</code> 向尾部推入一个元素<br />
<code>pop_back()</code> 从尾部弹出一个元素<br />
</p>

<p>
可以发现，使用 <code>deque</code> 可以模拟 <code>stack</code><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org151e06b" class="outline-3">
<h3 id="org151e06b">set</h3>
<div class="outline-text-3" id="text-org151e06b">
</div>
<div id="outline-container-org4a3e1ec" class="outline-4">
<h4 id="org4a3e1ec">头文件</h4>
<div class="outline-text-4" id="text-org4a3e1ec">
<p>
<code>#include &lt;set&gt;</code><br />
</p>
</div>
</div>
<div id="outline-container-orga24712b" class="outline-4">
<h4 id="orga24712b">简介</h4>
<div class="outline-text-4" id="text-orga24712b">
<p>
<code>set</code> 是集合，和数学上的集合一样，每个元素只能出现一次，这对于统计有多少个不同的元素是很方便的。<br />
</p>

<p>
顺便说一句， <code>set</code> 的复杂度都 <code>O(logN)</code> 的，它的底层实现是红黑树<br />
</p>
</div>
</div>
<div id="outline-container-org01a862a" class="outline-4">
<h4 id="org01a862a">使用</h4>
<div class="outline-text-4" id="text-org01a862a">
<p>
<code>set&lt;类型名&gt; 集合名</code> 创建一个 <code>set</code><br />
</p>

<p>
<code>set</code> 的函数有：<br />
<code>insert()</code> 插入一个元素<br />
<code>erase()</code> 删除元素<br />
<code>clear()</code> 清空集合<br />
<code>find()</code> 在集合内查找元素，并返回它在集合内的引用<br />
<code>count()</code> 统计元素在集合内的个数，它的返回值只能是1或0<br />
<code>empty()</code> 返回集合是否为空<br />
<code>size()</code> 集合的元素个数<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org67910a2" class="outline-3">
<h3 id="org67910a2">map</h3>
<div class="outline-text-3" id="text-org67910a2">
</div>
<div id="outline-container-org1972e19" class="outline-4">
<h4 id="org1972e19">头文件</h4>
<div class="outline-text-4" id="text-org1972e19">
<p>
<code>#include &lt;map&gt;</code><br />
</p>
</div>
</div>
<div id="outline-container-orgecc1a7e" class="outline-4">
<h4 id="orgecc1a7e">简介</h4>
<div class="outline-text-4" id="text-orgecc1a7e">
<p>
<code>map</code> 的意思其实是映射，它可以保存 <code>key</code> 到 <code>value</code> 的映射，也就是键值对<br />
说人话，就像数组可以通过下标访问元素， <code>map</code> 也是通过 <code>key</code> 访问元素，不同于数组 <code>map</code> 的 <code>key</code> 可以是数字、字符、字符串等等<br />
一个 <code>key</code> 只能映射到一个 <code>value</code><br />
</p>

<p>
<code>map</code> 的复杂度也都是 <code>O(logN)</code><br />
</p>
</div>
</div>
<div id="outline-container-org2e09807" class="outline-4">
<h4 id="org2e09807">使用</h4>
<div class="outline-text-4" id="text-org2e09807">
<p>
<code>map&lt;键类型, 值类型&gt; 映射名</code> 可以创建一个 <code>map</code> 需要标注好键和值的类型<br />
</p>

<p>
使用方法和数组类似 <code>map1[键]</code> 就可以返回对应键的值了<br />
</p>

<p>
比如 <code>map&lt;char, int&gt; m</code> 创建了名为 <code>m</code> 的映射，它可以把一个字符映射到一个整数数字上<br />
<code>m['a'] = 100</code> 就把100保存到a这个键内了<br />
<code>m['a']</code> 对这个表达式求值就返回100了<br />
</p>

<p>
<code>map</code> 的函数：<br />
<code>count()</code> 统计一个键的数量<br />
<code>find()</code> 返回对应键在映射内的指针<br />
<code>size()</code> 返回全部元素个数<br />
<code>empty()</code> 返回映射是否为空<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org86c0756" class="outline-3">
<h3 id="org86c0756">sort</h3>
<div class="outline-text-3" id="text-org86c0756">
</div>
<div id="outline-container-orgdcf9300" class="outline-4">
<h4 id="orgdcf9300">头文件</h4>
<div class="outline-text-4" id="text-orgdcf9300">
<p>
<code>#include &lt;algorithm&gt;</code><br />
</p>

<p>
这个头文件内有许多算法的实现，比如等下要讲的排序<br />
</p>
</div>
</div>
<div id="outline-container-org79c612f" class="outline-4">
<h4 id="org79c612f">简介</h4>
<div class="outline-text-4" id="text-org79c612f">
<p>
<code>sort</code> 是排列的意思，它可以对给定范围内的数据进行排序，传入一个比较函数就可以控制是从小到大还是从大到小排序了。<br />
</p>

<p>
<code>sort</code> 排列的复杂度是 <code>O(n*logN)</code><br />
</p>
</div>
</div>
<div id="outline-container-org20fd55e" class="outline-4">
<h4 id="org20fd55e">用法</h4>
<div class="outline-text-4" id="text-org20fd55e">
<p>
<code>sort(起始引用,未尾引用)</code> 就可以对这个范围内的数据排序了，需要注意未尾引用是最后一个元素的引用加1<br />
</p>

<p>
不需要指定被排序数据的类型， <code>sort</code> 会自动判断<br />
可以为第三个参数添加一个比较函数，让 <code>sort</code> 使用这个函数的规则排序<br />
</p>

<div class="org-src-container">
<pre class="src src-c++">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

bool cmp1(int a, int b) { return a &gt; b; }

int main() {
  vector&lt;int&gt; a = {9, 6, 3, 8, 5, 2, 7, 4, 1, 0};
  sort(a.begin(), a.end());
  for (int i = 0; i &lt; a.size(); i++)
    cout &lt;&lt; a[i] &lt;&lt; " ";
  cout &lt;&lt; endl;

  sort(a.begin(), a.end(), cmp1);
  for (int i = 0; i &lt; a.size(); i++)
    cout &lt;&lt; a[i] &lt;&lt; " ";
  cout &lt;&lt; endl;

  int b[] = {9, 6, 3, 8, 5, 2, 7, 4, 1, 0};
  sort(b, b + 10);
  for (int i = 0; i &lt; 10; i++)
    cout &lt;&lt; b[i] &lt;&lt; " ";
  cout &lt;&lt; endl;

  sort(b, b + 10, cmp1);
  for (int i = 0; i &lt; 10; i++)
    cout &lt;&lt; b[i] &lt;&lt; " ";
  cout &lt;&lt; endl;
  return 0;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org7d1d80b" class="outline-3">
<h3 id="org7d1d80b">next_permutation</h3>
<div class="outline-text-3" id="text-org7d1d80b">
</div>
<div id="outline-container-orga7be4e3" class="outline-4">
<h4 id="orga7be4e3">头文件</h4>
<div class="outline-text-4" id="text-orga7be4e3">
<p>
<code>#include &lt;algorithm&gt;</code><br />
</p>
</div>
</div>
<div id="outline-container-org3ea9a21" class="outline-4">
<h4 id="org3ea9a21">简介</h4>
<div class="outline-text-4" id="text-org3ea9a21">
<p>
<code>next_permutation</code> 可以生成一个范围内数据的下一个排列<br />
比如 <code>1 2 3</code> 的下一个排列就是 <code>1 3 2</code><br />
这个函数的作用是非常大的，以后做有些算法题时，如果不想用递归写 <code>dfs</code> 可以使用这个函数解决<br />
</p>

<p>
比如有一些人想接水，每个人接水的时间不同，我们想让所有人的等待时间之和最小，使用暴力的方法，把这些人的每种排列情况都算一遍就能得到答案了，当然这道题使用其它的方法更简单<br />
</p>
</div>
</div>
<div id="outline-container-org19f27e2" class="outline-4">
<h4 id="org19f27e2">使用方法</h4>
<div class="outline-text-4" id="text-org19f27e2">
<p>
<code>next_permutation(起始引用,未尾引用)</code> 会生成范围内的下一个排列，如果不能生成了就返回 <code>false</code><br />
</p>

<div class="org-src-container">
<pre class="src src-c++">#include &lt;algorithm&gt;
#include &lt;iostream&gt;

using namespace std;

int main() {
  int all[] = {1, 2, 3, 4, 5};
  do {
    for (int i = 0; i &lt; 5; i++)
      cout &lt;&lt; all[i] &lt;&lt; " ";
    cout &lt;&lt; endl;
  } while (next_permutation(all, all + 5));
  return 0;
}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgb51b647" class="outline-2">
<h2 id="orgb51b647">结语</h2>
<div class="outline-text-2" id="text-orgb51b647">
<p>
这篇文章只讲解了 <code>C/C++</code> 的一下部分内容，如果你对其它的部分也感兴趣的话，我推荐一本书 《C++ Prime Plus》<br />
</p>
</div>
</div>

</div>
</div>

        <div>
      <div class="post-meta">
        <span title="post date" class="post-info">2020-11-17</span>
        <span title="last modification date" class="post-info">2020-12-11</span>
        <span title="tags" class="post-info"><a href="/tags/tutorial/">tutorial</a>, <a href="/tags/c-c++/">C/C++</a></span>
        <span title="author" class="post-info">lampze</span>
      </div>
      <section>
        <h1>Comments</h1>
      </section>
      <script src="//code.jquery.com/jquery-latest.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.js"></script>
      <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script src="/media/js/main.js"></script>
      <div class="footer">
        <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 28.x (<a href="http://orgmode.org">Org mode</a> 9.x)</p>
        <p>
          Copyright &copy; 2012 - <span id="footerYear"></span> <a href="mailto:1229408499 &lt;at&gt; qq &lt;dot&gt; com">lampze</a>
          &nbsp;&nbsp;-&nbsp;&nbsp;
          Powered by <a href="https://github.com/kelvinh/org-page" target="_blank">org-page</a>
          <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
        </p>
      </div>
    </div>

  </body>
</html>
