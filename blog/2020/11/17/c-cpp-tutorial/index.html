<!DOCTYPE html>
<html lang="en-us">
  <head>
  <title>C/C++简明教程 - org-page</title>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta name="author" content="lampze" />
    <meta name="description" content="C/C++的简单教程" />
    <meta name="keywords" content="tutorial, C/C++" />
  <link rel="stylesheet" media="screen" href="/media/css/font.css" rel="stylesheet" type="text/css"/>
  <link rel="stylesheet" href="/media/css/main.css" type="text/css">
  <link rel="stylesheet" href="/media/css/prettify.css" type="text/css">
</head>

  <body class="container">
    <div>
  <header class="masthead">
    <h1 class="masthead-title"><a href="/">org-page</a></h1>
    <p>static site generator</p>
    <nav class="site-nav">
      <div class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z" fill="#ffff00"/>
          <path d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z" fill="#ffff00"/>
          <path d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z" fill="#ffff00"/>
        </svg>
      </div>
      <ul class="trigger">
          <li><a href="/blog/">Blog</a></li>
        <li><a href="/tags/">Tags</a></li>
        <li><a href="/about/">About</a></li>
        <li><a href="https://github.com/lampze/">GitHub</a></li>
        <li><a href="/rss.xml">RSS</a></li>
      </ul>
    </nav>
    <form method="get" id="searchform" action="//www.google.com/search">
      <input type="text" class="field" name="q" id="s" placeholder="Search">
      <input type="hidden" name="as_sitesearch" value="lampze.github.io">
    </form>
  </header>
</div>

    <div>
<div class="post">
<h1 class="title">C/C++简明教程</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgc40270c">前言</a></li>
<li><a href="#org66c9b17">C语言</a>
<ul>
<li><a href="#org5a9e3b7">编程与运行流程</a>
<ul>
<li><a href="#org1b3a51f">写代码</a></li>
<li><a href="#org32da91f">编译</a></li>
<li><a href="#orgf287634">运行过程</a></li>
</ul>
</li>
<li><a href="#org721118f">语法简介</a></li>
<li><a href="#org481f2f6">变量</a>
<ul>
<li><a href="#org8332b88">简介</a></li>
<li><a href="#org6cf0e3e">类型</a></li>
<li><a href="#org0cb8270">创建</a></li>
<li><a href="#orga552a21">使用</a></li>
</ul>
</li>
<li><a href="#org8aa7024">输入输出</a>
<ul>
<li><a href="#org05db6aa">简介</a></li>
<li><a href="#orgb898b01">输出</a></li>
<li><a href="#orgbe121d1">输入</a></li>
</ul>
</li>
<li><a href="#org29b2b95">选择</a>
<ul>
<li><a href="#org25aa373">简介</a></li>
<li><a href="#orgd348735">if</a></li>
<li><a href="#org752af99">switch</a></li>
<li><a href="#org69bd41e">三元运算符</a></li>
</ul>
</li>
<li><a href="#org52c924f">循环</a>
<ul>
<li><a href="#org72b6b6a">简介</a></li>
<li><a href="#orgce57cb3">while</a></li>
<li><a href="#org9a1c011">for</a></li>
</ul>
</li>
<li><a href="#orgbbe07ae">数组</a>
<ul>
<li><a href="#org1a53148">简介</a></li>
<li><a href="#org473e525">语法</a></li>
<li><a href="#org0e605f3">插入排序</a></li>
</ul>
</li>
<li><a href="#org2efb880">指针</a>
<ul>
<li><a href="#org58aca7a">简介</a></li>
<li><a href="#orgdd708c3">语法</a></li>
<li><a href="#orgb8b516d">用法</a></li>
<li><a href="#orgfbf3413">数组</a></li>
</ul>
</li>
<li><a href="#org98f00ff">函数</a>
<ul>
<li><a href="#org3248967">简介</a></li>
<li><a href="#org57ae5a8">语法</a></li>
<li><a href="#org2d9e2fd">例子</a></li>
</ul>
</li>
<li><a href="#org47dc3e6">递归</a>
<ul>
<li><a href="#org75f165a">简介</a></li>
<li><a href="#orge5d913a">fib</a></li>
</ul>
</li>
<li><a href="#org53fd7b3">结构体</a>
<ul>
<li><a href="#org8ec4c7e">简介</a></li>
<li><a href="#orga93dfa4">语法</a></li>
<li><a href="#org513c236">结构体指针</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org1a02f6c">C++</a>
<ul>
<li><a href="#org17ea410">stl</a></li>
<li><a href="#org0b9dde2">输入输出</a>
<ul>
<li><a href="#orgc5269a9">头文件</a></li>
<li><a href="#orgcaf478f">cin</a></li>
<li><a href="#org29c2c53">cout</a></li>
<li><a href="#org226f1cb">总结</a></li>
</ul>
</li>
<li><a href="#orgd1852ed">vector</a>
<ul>
<li><a href="#orge91833c">头文件</a></li>
<li><a href="#org92b7735">简介</a></li>
<li><a href="#orgfe9e662">创建</a></li>
<li><a href="#org667ec81">使用</a></li>
</ul>
</li>
<li><a href="#org08b29e5">string</a>
<ul>
<li><a href="#org23b7495">头文件</a></li>
<li><a href="#orged7dc94">简介</a></li>
<li><a href="#orga84c4c9">使用</a></li>
</ul>
</li>
<li><a href="#org9312bbb">queue</a>
<ul>
<li><a href="#org5970941">头文件</a></li>
<li><a href="#org08ebaa5">简介</a></li>
<li><a href="#orgfedbe79">使用</a></li>
</ul>
</li>
<li><a href="#org3640569">stack</a>
<ul>
<li><a href="#org6e927e2">头文件</a></li>
<li><a href="#org6f38381">简介</a></li>
<li><a href="#org9607100">使用</a></li>
</ul>
</li>
<li><a href="#org8138938">set</a>
<ul>
<li><a href="#orgc8f6e10">头文件</a></li>
<li><a href="#orgf130e0f">简介</a></li>
<li><a href="#org9190f48">使用</a></li>
</ul>
</li>
<li><a href="#orgddf2b1a">map</a>
<ul>
<li><a href="#orgef72671">头文件</a></li>
<li><a href="#org83c2a0c">简介</a></li>
<li><a href="#org08467af">使用</a></li>
</ul>
</li>
<li><a href="#org653cca2">sort</a>
<ul>
<li><a href="#orga28bde7">头文件</a></li>
<li><a href="#orgb41477a">简介</a></li>
<li><a href="#orgb6d4f20">用法</a></li>
</ul>
</li>
<li><a href="#orgc2b3c1b">next_permutation</a>
<ul>
<li><a href="#org7c1432f">头文件</a></li>
<li><a href="#org090dc9d">简介</a></li>
<li><a href="#org7675c44">使用方法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orga806ca7">结语</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgc40270c" class="outline-2">
<h2 id="orgc40270c">前言</h2>
<div class="outline-text-2" id="text-orgc40270c">
<p>
编程语言是让我们使用一个大部分人能理解的方式控制计算机，所以写代码时最重要的是可读性，对自己要求高的同学可以思考怎么保持代码的整洁与优雅。<br />
</p>

<p>
本文不会把每种表都列出来（如优先级、关键字等），这些网上或课本上都有，请自行翻阅，本书仅仅是讲清原理与我自己理解的逻辑。<br />
</p>

<p>
本文只把基础的逻辑与用法讲清楚，最后可能会附带几个例题，想要真正的学会编程还是要多写代码。<br />
</p>

<p>
如果对更加细节的部分感兴趣，可以看看这些：<a href="https://www.runoob.com/cprogramming/c-tutorial.html">C 语言教程</a>、<a href="https://github.com/jobbole/awesome-c-cn">awesome-c-cn</a><br />
</p>

<p>
最后请看看这篇文章《<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md">提问的智慧</a>》，问问题时请按照这上面做。<br />
</p>
</div>
</div>

<div id="outline-container-org66c9b17" class="outline-2">
<h2 id="org66c9b17">C语言</h2>
<div class="outline-text-2" id="text-org66c9b17">
</div>
<div id="outline-container-org5a9e3b7" class="outline-3">
<h3 id="org5a9e3b7">编程与运行流程</h3>
<div class="outline-text-3" id="text-org5a9e3b7">
</div>
<div id="outline-container-org1b3a51f" class="outline-4">
<h4 id="org1b3a51f">写代码</h4>
<div class="outline-text-4" id="text-org1b3a51f">
<p>
对于 <code>windows</code> 来说，我推荐新手使用 <code>Dev-C++</code> 这个 <code>IDE</code> 来编写代码，这个软件虽然有些年头了，也很长时间没有更新了，但作为一个编程集成环境还是及格的，具体的操作还是比较简单，很多事情都能一键完成。<br />
对于参加蓝桥杯的同学， <code>Dev-C++</code> 也是官方指定的编程环境。<br />
请不要使用 <code>vc++</code> ！！！<br />
</p>

<p>
对于 <code>Linux</code> 来说，新手可以使用 <code>nano</code> 来编写代码，有基础的同学可以学下 <code>vim</code> ，进阶的话可以玩玩 <code>Emacs</code> 。<br />
</p>
</div>
</div>
<div id="outline-container-org32da91f" class="outline-4">
<h4 id="org32da91f">编译</h4>
<div class="outline-text-4" id="text-org32da91f">
<p>
对于 <code>IDE</code> 来说只需要按下按钮就能自动的编译了，没有什么需要动脑的地方。<br />
</p>

<p>
当然我们不能这样就行了，下面简单介绍下编译是什么。我们写的代码其实都是文本文件，计算机并不认识，计算机只能处理2进制的指令，也就是机器语言，每种 <code>CPU</code> 的机器语言都是不一样的，所以我们需要把我们认识的代码转换成计算机认识机器代码，这个过程叫做编译。<br />
</p>

<p>
目前使用最广的编译器是 <code>gcc</code> ， <code>Dev-C++</code> 也是使用的这个编译器，安装 <code>gcc</code> 后可以在命令行使用 <code>gcc</code> 命令，这个命令给定一个源代码文件，然后输出一个二进制文件，然后计算机就能执行这个二进制文件了。<br />
</p>
</div>
</div>
<div id="outline-container-orgf287634" class="outline-4">
<h4 id="orgf287634">运行过程</h4>
<div class="outline-text-4" id="text-orgf287634">
<div class="org-src-container">
<pre class="src src-c">#include &lt;stdio.h&gt;

int main() {
  printf("Hello, World\n");
  return 0;
}
</pre>
</div>

<p>
对于 <code>C</code> 来说，它运行时总会从 <code>main</code> 函数开始，只要 <code>main</code> 函数结束整个程序就结束了。对于上面这个代码来说，它输出了一行 <code>Hello，World</code> 文本，并返回了0。需要注意这个0是返回给了操作系统，作用只有一个，就是告诉操作系统这个程序运行过程是否有错误，0表示没有错误。<br />
</p>

<p>
注意 <code>main</code> 只是第一个执行的函数，定义语句、引入库函数语句、宏语句等肯定是要优先执行的。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org721118f" class="outline-3">
<h3 id="org721118f">语法简介</h3>
<div class="outline-text-3" id="text-org721118f">
<p>
我们从简单的语句开始，语句由表达式组成，一条语句必须有一个分号当作结尾，比如 <code>1+1;</code> 就是一条语句。这条语句中的 <code>+</code> 是 <code>C</code> 自带的一些操作符，数学上常用的运算符都有。这里需要强调一下 <code>=</code> 是赋值运算符，比如 <code>a=b;</code> 的意思就是把a的值设置成b的值，也即对等号右边的表达式进行求值，然后把返回值赋值给左边。变量可以简单理解为一个箱子，箱子可以放置或取出数据。<br />
</p>

<p>
下面讲解表达式，每个表达式都有返回值，同一时刻只能运算一个操作。对于 <code>1+1+1</code> 这个表达式，它的求值过程是这样的：<br />
</p>
<ol class="org-ol">
<li>先运算第一个 <code>1+1</code> ，它的返回值是 <code>2</code><br /></li>
<li>表达式变成 <code>2+1</code><br /></li>
<li>得出返回值 <code>3</code><br /></li>
</ol>

<p>
记住分辩操作是跟根据操作符来的，有些操作符是需要两边都有数据，有些只需要一个，并且每个操作符都有优先级的，计算机会优先执行优先级高的操作，优先级一般来说符合直觉<br />
如果是同级的操作，根据操作符的类型来判定是从左到右还是从右到左。<br />
如果记不住执行的顺序，可以简单的使用括号把你想要独立执行的操作括起来，括号内的会优先执行。<br />
比如 <code>(1 + 2) * 3</code> -&gt; <code>(3) * 3</code> -&gt; <code>3 * 3</code> -&gt; <code>9</code><br />
</p>

<p>
这样就是最基本的 <code>C</code> 语法，更加复杂的语法在后面讲解。<br />
</p>
</div>
</div>
<div id="outline-container-org481f2f6" class="outline-3">
<h3 id="org481f2f6">变量</h3>
<div class="outline-text-3" id="text-org481f2f6">
</div>
<div id="outline-container-org8332b88" class="outline-4">
<h4 id="org8332b88">简介</h4>
<div class="outline-text-4" id="text-org8332b88">
<p>
变量可以理解成一个箱子，我们可以把一些东西放到箱子，也可以从箱子内把东西取出来。<br />
类型的作用只是为每个箱子打上了标签，规定了箱子内不能随便放东西，比如一个放水果的箱子就不能把水倒进去。<br />
</p>
</div>
</div>
<div id="outline-container-org6cf0e3e" class="outline-4">
<h4 id="org6cf0e3e">类型</h4>
<div class="outline-text-4" id="text-org6cf0e3e">
<p>
<code>C</code> 是一个强类型的语言，它的意思就是每个数据都有类型，不同类型的数据不能随便使用，比如一个整数类型的变量就不能放入一个小数数据。<br />
</p>

<p>
<code>C</code> 里有三种简单常用的类型：整数、小数、字符；<br />
</p>

<p>
我们需要记下这些类型的名称<br />
整数有： <code>short</code> 、 <code>int</code> 、 <code>long</code> 、 <code>long long</code><br />
小数有： <code>float</code> 、 <code>doubel</code><br />
字符有： <code>char</code><br />
</p>

<p>
这些不同的类型之间的区别只是它们用来存储数据的空间大小，比如 <code>short</code> 只用2个字节存储整数。<br />
对于初学者只需要记下 <code>int</code> 、 <code>float</code>  、 <code>char</code> 就行了。<br />
</p>
</div>
</div>

<div id="outline-container-org0cb8270" class="outline-4">
<h4 id="org0cb8270">创建</h4>
<div class="outline-text-4" id="text-org0cb8270">
<p>
创建一个变量需要使用变量声明语句，大概是这种形式 <code>&lt;变量类型&gt; &lt;变量名&gt;;</code> ，举个例子 <code>int a;</code> 这样就创建了一个 <code>int</code> 类型的变量 <code>a</code> 。<br />
</p>

<p>
如果使用这种形式 <code>&lt;变量类型&gt; &lt;变量名&gt; = &lt;表达式&gt;;</code> 的语句声明变量的话，就会给这个变量一个初始值，比如 <code>float pi = 3.1415926;</code> 就定义了一个 <code>float</code> 类型的变量 <code>pi</code> ，它的初始值为 <code>3.1415926</code> 。<br />
</p>

<p>
注意一点，变量名不能与 <code>C</code> 的关键字重名，已经使用过的名字不能重复定义。<br />
</p>
</div>
</div>
<div id="outline-container-orga552a21" class="outline-4">
<h4 id="orga552a21">使用</h4>
<div class="outline-text-4" id="text-orga552a21">
<p>
在表达式内，我们可以把变量当作一个求值操作，这个操作的返回值为变量内的值，比如 <code>int a = 1;</code> 后 <code>a</code> 这个表示式的值就为 <code>1</code> ， <code>(a + 1) * a</code> -&gt; <code>(1 + 1) * a</code> -&gt; <code>2 * a</code> -&gt; <code>2 * 1</code> -&gt; <code>2</code> 。<br />
</p>

<p>
对于变量我们还可以对它使用赋值运算符，比如 <code>=</code> 、 <code>++</code> 、 <code>--</code> <br />
<code>=</code> 就是简单的把等号右边的表示式求值，放到等号左边的变量内<br />
<code>++</code> 是把变量内的值加上1，然后放到变量内<br />
<code>--</code> 是把变量内的值减去1，然后放入变量内<br />
</p>

<p>
赋值运算也是一个表示式，这意味着它也会返回一个值<br />
比如 <code>1 + (a = 3)</code> -&gt; <code>1 + 3</code> -&gt; <code>4</code><br />
需要注意这个表示式会有一个副作用，它把 <code>a</code> 的值改变成 <code>3</code> 了<br />
</p>

<p>
后面两个运算符有些许的复杂<br />
<code>a++</code> 的返回值是 <code>a</code><br />
<code>++a</code> 的返回值是 <code>a+1</code><br />
<code>a--</code> 的返回值是 <code>a--</code><br />
<code>--a</code> 的返回值是 <code>a-1</code><br />
注意，虽然返回值不一样，但这个变量的值都改变了，也即是一个副作用<br />
</p>

<p>
下面举些例子 <code>int a = 1;</code><br />
<code>1 + a++</code> -&gt; <code>1 + 1</code> -&gt; <code>2</code><br />
<code>a</code> -&gt; <code>2</code><br />
<code>1 + (++a)</code> -&gt; <code>1 + 3</code> -&gt; <code>4</code><br />
<code>a</code> -&gt; <code>3</code><br />
<code>1 + a--</code> -&gt; <code>1 + 3</code> -&gt; <code>4</code><br />
<code>a</code> -&gt; <code>2</code><br />
<code>1 + (--a)</code> -&gt; <code>1 + 1</code> -&gt; <code>2</code><br />
<code>a</code> -&gt; <code>1</code><br />
</p>

<p>
变量不能放入不同类型的数据，但把小数放到整数的盒子里肯定是常见的操作，这种不同类型的数据之间的操作 <code>C</code> 是支持。 <code>C</code> 会对不同类型的数据自动进行类型转换，转换的规则是尽量减少信息的流失，比如 <code>short</code> 和 <code>int</code> 类型的数据运算，返回的结果是 <code>int</code> 类型的数据。小数转换成整数会直接把小数部分去掉，并不会四舍五入。<br />
对于赋值运行也是相同的道理<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org8aa7024" class="outline-3">
<h3 id="org8aa7024">输入输出</h3>
<div class="outline-text-3" id="text-org8aa7024">
</div>
<div id="outline-container-org05db6aa" class="outline-4">
<h4 id="org05db6aa">简介</h4>
<div class="outline-text-4" id="text-org05db6aa">
<p>
我们写一个程序，一般都是面向用户的，作为人类我们肯定是需要获取和输入一些信息，一个无法干涉无法感知的东西我们是不能使用的。<br />
</p>

<p>
下面我就介绍下 <code>C</code> 里的标准输入输出，标准输入输出可以理解成通用的接口，一般情况下我们都可以使用这个接口来输入输出信息。<br />
一般情况输入输出都是文本的形式。<br />
</p>

<p>
需要注意 <code>C</code> 默认不包含输入输出的功能，我们需要引入这些功能， <code>stdio.h</code> 这个头文件包含了我们需要的功能，使用 <code>#include &lt;stdio.h&gt;</code> 这个命令我们可以引入它。<br />
可以简单的把这个命令理解成把 <code>stdio.h</code> 这个文件里的内容放到我们程序的最前面。<br />
</p>

<p>
函数也可以理解成一个魔法盒子，它可以放入一些数据，然后扔出一些数据。<br />
</p>
</div>
</div>

<div id="outline-container-orgb898b01" class="outline-4">
<h4 id="orgb898b01">输出</h4>
<div class="outline-text-4" id="text-orgb898b01">
</div>
<ul class="org-ul">
<li><a id="orgbfe3a3d"></a>putchar<br />
<div class="outline-text-5" id="text-orgbfe3a3d">
<p>
这个函数很容易理解，传入一个字符，并把它输出， <code>c</code> 可以使用 <code>''</code> 包裹一个字符来表示一个字符常量，如果 <code>''</code> 内有多个字符就会报错。<br />
</p>

<p>
<code>putchar('a')</code> 语句输出 <code>a</code> 到标准输出。<br />
</p>
</div>
</li>
<li><a id="orge505c5b"></a>puts<br />
<div class="outline-text-5" id="text-orge505c5b">
<p>
同理这个函数也是传入一个字符串，并输出它，与字符的表示方式相似，我们使用 <code>""</code> 包裹多个字符来表示字符串变量。<br />
</p>

<p>
比如 <code>puts("Hello")</code> 语句就会输出 <code>Hello</code> 到标准输出。<br />
</p>
</div>
</li>
<li><a id="org15f4c39"></a>printf<br />
<div class="outline-text-5" id="text-org15f4c39">
<p>
格式化输出一串字符，它接收任意多个参数，第一个参数是一个字符串，并把它作为模板，里面可以放一些标识来表示需要把标识替换成我们想要的数据，后面的参数填入表达式，函数会按顺序把它们一个个填入模板字符串中。<br />
</p>

<div class="org-src-container">
<pre class="src src-c">#include &lt;stdio.h&gt;

int main() {
  /* 语句后面的注释里放输出的内容 */
  /* \n是转义字符，表示换行，因为有些字符不可输入 */
  printf("%d is a number\n", 123); /* 123 is a number */
  printf("%s is a string, and i like %c", "haha", 'a');/* haha is a string, and i like a */
  return 0;
}
</pre>
</div>
</div>
</li>
</ul>
</div>

<div id="outline-container-orgbe121d1" class="outline-4">
<h4 id="orgbe121d1">输入</h4>
<div class="outline-text-4" id="text-orgbe121d1">
</div>
<ul class="org-ul">
<li><a id="org4f42fac"></a>getchar<br />
<div class="outline-text-5" id="text-org4f42fac">
<p>
这个函数从标准输入读入一个字符然后返回，比如 <code>char c = getchar();</code> 这条语句就会从输入流获取一个字符，并赋值给变量 <code>c</code> 。<br />
</p>

<p>
<code>getchar</code> 只从输入拿下一个字符，所有的字符都可以拿下来，包括空白字符（空格、回车等等）<br />
</p>
</div>
</li>
<li><a id="org8403d94"></a>gets<br />
<div class="outline-text-5" id="text-org8403d94">
<p>
这个函数从标准输入读取一行字符，并把这一行填入一个字符数组。<br />
</p>

<div class="org-src-container">
<pre class="src src-c">#include &lt;stdio.h&gt;

int main() {
  char s[100];  /* 字符串可以理解成多个字符，所以c里面使用数组来表示字符串 */
  gets(s);      /* 与上面的getchar不同，它不会返回一个值 */
  puts(s);      /* 输出一个字符串 */
  return 0;
}
</pre>
</div>

<p>
请注意一行末尾的回车不会被填入字符数组。<br />
</p>
</div>
</li>
<li><a id="orgd3d3c03"></a>scanf<br />
<div class="outline-text-5" id="text-orgd3d3c03">
<p>
这个函数就可以支持多种形式格式的输入了，与上面的 <code>printf</code> 有相同的控制符。<br />
需要注意一点， <code>scanf</code> 填写变量的位置需要提供一个指针，获取变量指针的方法是使用 <code>&amp;</code> 运算符。<br />
使用 <code>%c</code> 时和 <code>getchar</code> 一样会读取空白字符<br />
使用 <code>%s</code> 时只要遇到一个空白字符就会停止<br />
</p>

<div class="org-src-container">
<pre class="src src-c">#include &lt;stdio.h&gt;

int main() {
  int n;
  char s[100];
  /* n是一个变量需要使用 &amp; 获取它的指针
   * 而数组名就是一个指针 */
  scanf("%d %s", &amp;n, s);
  printf("%d %s\n", n, s);
  return 0;
}
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-org29b2b95" class="outline-3">
<h3 id="org29b2b95">选择</h3>
<div class="outline-text-3" id="text-org29b2b95">
</div>
<div id="outline-container-org25aa373" class="outline-4">
<h4 id="org25aa373">简介</h4>
<div class="outline-text-4" id="text-org25aa373">
<p>
选择结构的出现打破了我之前讲述的简洁明了的语法，我们需要重新学习一些额外的情况，所幸这种新结构并不复杂。<br />
</p>

<p>
选择结构有三种表达方式， <code>if</code> 、 <code>switch</code> 、 <code>三元运算符</code><br />
前面两种方式可以相互转换，而最后一种出现的目的是减少代码行数，同时也加重了我们理解程序的负担。<br />
</p>

<p>
需要注意一点，在选择结构内如果执行了 <code>break</code> 会直接结束当前的选择结构。<br />
</p>
</div>
</div>
<div id="outline-container-orgd348735" class="outline-4">
<h4 id="orgd348735">if</h4>
<div class="outline-text-4" id="text-orgd348735">
<p>
它的语法大概是这样 <code>if (表达式) { 代码块 }</code><br />
简单来说如果对表达式求值的结果为真，就执行使用 <code>{}</code> 包裹的代码块<br />
<code>c</code> 里面使用 <code>0</code> 表示假，而其它的任何值都为真<br />
所谓代码块就是任意行语句<br />
</p>

<p>
如果需要执行的语句只有一行可以使用 <code>if (表达式-判断) 表达式-执行;</code> 的形式，表达式可以不写。<br />
</p>

<p>
如果我们还要对表达式为假的情况做些操作，并不用再写一个 <code>if</code> ，可以使用下述方式<br />
<code>if (表达式) {为真时执行} else {为假时执行}</code><br />
同理，只有一条语句时可以省略 <code>{}</code><br />
下面看一个例子<br />
</p>

<div class="org-src-container">
<pre class="src src-c">#include &lt;stdio.h&gt;

int main() {
  int a = 10;
  if (a &lt; 20)
    puts("a &lt; 20\n");
  
  if (a &gt; 100)
    puts("a &gt; 100");
  else
    puts("a &lt;= 100");

  if (a &gt; 10)
    puts("a &gt; 10\n");
  else if (a &lt; 10)
    puts("a &lt; 10\n");
  else
    puts("a == 10\n");
  return 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org752af99" class="outline-4">
<h4 id="org752af99">switch</h4>
<div class="outline-text-4" id="text-org752af99">
<p>
<code>switch</code> 的语法比较复杂，简单来说它会把你给予的一个整数与 <code>case</code> 语句从上到下一一比对<br />
如果跟 <code>case</code> 语句后面的值相等，就执行 <code>case</code> 对应的代码块<br />
<code>default</code> 表示没有一个 <code>case</code> 语句匹配时的情况<br />
</p>

<div class="org-src-container">
<pre class="src src-c">#include &lt;stdio.h&gt;

int main() {
  switch(10) {
    case 10:
      puts("10");
    case 9:
      puts("9");
    default:
      puts("not match");
  }
  return 0;
}
</pre>
</div>

<p>
需要注意，有匹配项后它会忽略当前 <code>case</code> 后面的所有 <code>case</code> 条件，即它会执行匹配 <code>case</code> 后面的所有语句，直到 <code>switch</code> 结构结束。<br />
所以我们一般对于每个 <code>case</code> 都会在它的结尾加上 <code>break</code><br />
</p>
</div>
</div>
<div id="outline-container-org69bd41e" class="outline-4">
<h4 id="org69bd41e">三元运算符</h4>
<div class="outline-text-4" id="text-org69bd41e">
<p>
它的语法比较简单 <code>条件?表达式1:表达式2</code><br />
对这个三元运算表达式求值时，如果条件为真就执行并返回表达式1的值，否则执行并返回表达式2的值<br />
</p>

<div class="org-src-container">
<pre class="src src-c">#include &lt;stdio.h&gt;

int main() {
  int a, b;
  scanf("%d %d", &amp;a, &amp;b);
  printf("the max number is:%d\n", a &gt; b ? a : b);
  return 0;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org52c924f" class="outline-3">
<h3 id="org52c924f">循环</h3>
<div class="outline-text-3" id="text-org52c924f">
</div>
<div id="outline-container-org72b6b6a" class="outline-4">
<h4 id="org72b6b6a">简介</h4>
<div class="outline-text-4" id="text-org72b6b6a">
<p>
我们继续来破坏 <code>c</code> 的简单性，这次介绍循环结构<br />
有两种方式来描述一个循环结构 <code>while</code> 、 <code>for</code><br />
</p>
</div>
</div>
<div id="outline-container-orgce57cb3" class="outline-4">
<h4 id="orgce57cb3">while</h4>
<div class="outline-text-4" id="text-orgce57cb3">
<p>
语法为 <code>while(条件) {代码块}</code><br />
与 <code>if</code> 的结构相似，与 <code>if</code> 不同的地方在于， <code>while</code> 会在代码块执行结束后重复检查条件，如果条件还是为真就继续执行代码块<br />
简单来说就是执行代码块直到条件为假。<br />
</p>

<div class="org-src-container">
<pre class="src src-c">#include &lt;stdio.h&gt;

int main() {
  int a = 10, sum = 0;
  while (a &gt; 0) {
    sum += a;
    a--;
  }
  printf("%d\n", sum);
  return 0;
}
</pre>
</div>

<p>
<code>while</code> 还有一种变形 <code>do while</code> ，它的语法为<br />
<code>do {代码块} while(条件);</code><br />
与 <code>while</code> 的差别就是它一定会执行一次代码块<br />
</p>
</div>
</div>
<div id="outline-container-org9a1c011" class="outline-4">
<h4 id="org9a1c011">for</h4>
<div class="outline-text-4" id="text-org9a1c011">
<p>
语法为： <code>for (初始化;条件;副作用){代码块}</code><br />
<code>for</code> 可以转换成 <code>while</code> 的形式<br />
<code>初始化;while(条件){代码块;副作用;}</code><br />
初始化部分会在代码块之前执行，并且只执行一次<br />
每次条件为真时会执行代码块<br />
而副作用部分会在每次代码块结束后执行<br />
</p>

<p>
<code>for</code> 可以理解成 <code>while</code> 的严格模式，它让你把一些容易忘记写的部分先写好，尽量避免出错的可能性，比如写 <code>while</code> 语句时有人可能就忘记在末尾加上递增语句了。<br />
</p>

<div class="org-src-container">
<pre class="src src-c">#include &lt;stdio.h&gt;

int main() {
  int a = 10, sum = 0;
  for (a = 10; a &gt; 0; a--) {
    sum += a;
  }
  printf("%d\n", sum);
  return 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgbbe07ae" class="outline-3">
<h3 id="orgbbe07ae">数组</h3>
<div class="outline-text-3" id="text-orgbbe07ae">
</div>
<div id="outline-container-org1a53148" class="outline-4">
<h4 id="org1a53148">简介</h4>
<div class="outline-text-4" id="text-org1a53148">
<p>
数组提供了简单声明多个变量的方法，假设你需要对100个数进行排序，如果采用以往声明变量的方式，你需要写100个变量名，而使用数组就能一行语句生成多个变量。<br />
</p>
</div>
</div>
<div id="outline-container-org473e525" class="outline-4">
<h4 id="org473e525">语法</h4>
<div class="outline-text-4" id="text-org473e525">
<p>
数组的语法非常简单 <code>类型名 数组名[数组大小]</code><br />
类型名和数组名与变量的声明相同，数组与变量的区别只在于后面的那个括号，括号定义了数组里包含多少个元素，使用 <code>数组名[下标]</code> 可以找到任意一个元素，而它的使用方式与普通变量并无区别<br />
声明数组后，数组的大小不可改变，如果下标超过声明的大小，程序可能会发生错误<br />
既然声明后不可改变大小，而一次想好数组大小是一件很头疼的事情，那么可以不可以让数组的大小跟随数据变化呢？<br />
比如我知道了有100个数据，那么我只用开一个长度为100的数组即可<br />
对于 <code>vc++</code> 这些使用低版本编译器的 <code>IDE</code> 来说这是不可行的，因为低版本的编译器 <code>[]</code> 内只能放常量<br />
但如果你使用 <code>Dev-C++</code> 的话就不用但这个问题，它是可以在 <code>[]</code> 内放表达式的<br />
</p>

<p>
注意第一个元素的下标为0<br />
</p>

<p>
我们对于 <code>类型名 数组名[行数][列数]</code> 这种形式的数组称为二维数组，同理我们能够声明任意维度的数组<br />
对于二维数组，使用它时必须填好两个 <code>[]</code> 内的内容，你可以简单画一个表格，这样方便理解<br />
</p>
</div>
</div>
<div id="outline-container-org0e605f3" class="outline-4">
<h4 id="org0e605f3">插入排序</h4>
<div class="outline-text-4" id="text-org0e605f3">
<div class="org-src-container">
<pre class="src src-c">#include &lt;stdio.h&gt;

int main() {
  int len, i, j;
  scanf("%d", &amp;len);        /* 输入数组长度 */
  int arr[len];             /* 动态定义数组 */
  for (i = 0; i &lt; len; i++) /* 输入数据 */
    scanf("%d", arr + i);

  /* 使用插入排序，下面介绍一下原理
   * 简单来说对于每个i，找到i后面最小的元素，并让它与i位置的元素交换
   * 也既保持每个i上的元素都比之后的元素小 */
  for (i = 0; i &lt; len; i++)
    for (j = i + 1; j &lt; len; j++)
      if (arr[i] &gt; arr[j]) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
      }

  /* 输出数据 */
  for (i = 0; i &lt; len; i++)
    printf("%d ", arr[i]);
  printf("\n");
  return 0;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org2efb880" class="outline-3">
<h3 id="org2efb880">指针</h3>
<div class="outline-text-3" id="text-org2efb880">
</div>
<div id="outline-container-org58aca7a" class="outline-4">
<h4 id="org58aca7a">简介</h4>
<div class="outline-text-4" id="text-org58aca7a">
<p>
前面我们介绍了变量，变量我把它形容成一个盒子，盒子可以往里面放或拿东西<br />
现在想像一下，我们把所有的盒子都放到地上，按顺序一个一个编号<br />
如果有人想用盒子就标记一下这个盒子被占用了，并自己记下盒子的编号，然后就可以自由使用这个盒子了<br />
这个编号我们就称之为地址，而指针也是一个盒子，但它里面装着的东西只能是地址，也即一个地址类型的变量<br />
或者可以想像成一个里面放着纸条的盒子，纸条上写着一个盒子的地址<br />
</p>
</div>
</div>
<div id="outline-container-orgdd708c3" class="outline-4">
<h4 id="orgdd708c3">语法</h4>
<div class="outline-text-4" id="text-orgdd708c3">
<p>
<code>类型 *指针名</code> 就可以声明一个指针了<br />
需要注意一下 <code>int* a, b</code> 并不会声明指针 <code>a</code> <code>b</code> ，而是声明一个指针 <code>a</code> 与一个变量 <code>b</code><br />
所以写代码时请让 <code>*</code> 挨着指针名<br />
</p>
</div>
</div>
<div id="outline-container-orgb8b516d" class="outline-4">
<h4 id="orgb8b516d">用法</h4>
<div class="outline-text-4" id="text-orgb8b516d">
<p>
指针可以放地址，但是我们怎么获得一个地址呢？<br />
有些同学可能已经想到了，我们之前用 <code>scanf</code> 的时候使用一个操作符 <code>&amp;</code><br />
使用 <code>&amp;变量</code> 的方式，我们就能获得变量的地址了<br />
但我们对指针求值得到的结果是一个地址，那么我们怎么使用指针指向的变量呢？<br />
很简单，我们可以使用 <code>*指针</code> 的方式来找到那个地址<br />
通俗来说，跟着盒子内的纸条找到另一个盒子<br />
<code>*指针</code> 和普通变量的用法是一样的<br />
</p>
</div>
</div>
<div id="outline-container-orgfbf3413" class="outline-4">
<h4 id="orgfbf3413">数组</h4>
<div class="outline-text-4" id="text-orgfbf3413">
<p>
对于数组来说，数组名其实是一个指针，它保存的是数组的起始地址<br />
我们先定义一个数组 <code>int arr[10]</code><br />
我们可以发现 <code>arr[2]</code> 和 <code>*(arr+2)</code> 的效果是一样的，其实 <code>arr[2]</code> 是一个<a href="https://baike.baidu.com/item/%E8%AF%AD%E6%B3%95%E7%B3%96">语法糖</a><br />
<code>arr+2</code> 的意思就是找到 <code>arr</code> 之后两个位置的地址<br />
需要注意指针会自动识别一个单元格的大小<br />
</p>

<p>
还记得之前我们说过 <code>vc++</code> 不能动态定义数组长度吗？<br />
现在我们通过指针来实现这一功能<br />
首先先引入 <code>stdlib.h</code> 库，我们要使用 <code>malloc</code> 函数，这个函数可以让我们向系统申请内存，也就是和盒子的例子一样，我们登记一个盒子<br />
然后这样 <code>int *arr = (int *)malloc(sizeof(int) * len)</code> 就可以定义一个len长度的数组了<br />
</p>

<div class="org-src-container">
<pre class="src src-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
  int len, i, j;
  scanf("%d", &amp;len);                           /* 输入数组长度 */
  int *arr = (int *)malloc(sizeof(int) * len); /* 动态定义数组 */
  for (i = 0; i &lt; len; i++)                    /* 输入数据 */
    scanf("%d", arr + i);

  /* 使用插入排序，下面介绍一下原理
   * 简单来说对于每个i，找到i后面最小的元素，并让它与i位置的元素交换
   * 也既保持每个i上的元素都比之后的元素小 */
  for (i = 0; i &lt; len; i++)
    for (j = i + 1; j &lt; len; j++)
      if (arr[i] &gt; arr[j]) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
      }

  /* 输出数据 */
  for (i = 0; i &lt; len; i++)
    printf("%d ", arr[i]);
  printf("\n");
  return 0;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org98f00ff" class="outline-3">
<h3 id="org98f00ff">函数</h3>
<div class="outline-text-3" id="text-org98f00ff">
</div>
<div id="outline-container-org3248967" class="outline-4">
<h4 id="org3248967">简介</h4>
<div class="outline-text-4" id="text-org3248967">
<p>
函数让我们可以把一堆操作封装起来，下次可以直接使用，数学一点的像pi、cos、sin等都可以用函数封装起来，再比如打印一行星号、对数组进行排序、计算fib数列之类的。<br />
</p>

<p>
如果你以后开发一个比较大型的应用，把所有语句写在 <code>main</code> 函数里当然也可以，但如果你突然发现一个功能写错了，那么你可以会痛苦的找上很久 <code>bug</code> 。<br />
而如果你模块化的把每个功能都封装好成一个个函数，那么你就能单独的测试每个函数，更妙的是如果你把每个函数的名字起的好，那么你的程序就可以像读文章一样，不需要注释也能读懂。<br />
</p>
</div>
</div>
<div id="outline-container-org57ae5a8" class="outline-4">
<h4 id="org57ae5a8">语法</h4>
<div class="outline-text-4" id="text-org57ae5a8">
<p>
<code>返回类型 函数名(类型1 参数1，类型2 参数2){函数体}</code> 就可以创建一个函数<br />
每个函数都要定义好返回类型，函数可以有多个参数，每个参数都必须定义类型，因为 <code>c</code> 是强类型的语言<br />
变量进入函数时，函数并不会使用原来的变量，而是把变量里的内容复制到一个新建的变量，记住这一点！！！<br />
函数只能有一个返回值，那么我想返回多个值怎么办呢？<br />
我们可以返回一个结构体<br />
</p>
</div>
</div>
<div id="outline-container-org2d9e2fd" class="outline-4">
<h4 id="org2d9e2fd">例子</h4>
<div class="outline-text-4" id="text-org2d9e2fd">
<p>
我们来简单的举一个例子，交换变量里的值<br />
我们先看看错误的例子<br />
</p>

<div class="org-src-container">
<pre class="src src-c">#include &lt;stdio.h&gt;

void swap(int a, int b) {
  int temp = a;
  a = b;
  b = temp;
}

int main() {
  int a, b;
  scanf("%d %d", &amp;a, &amp;b);
  swap(a, b);
  printf("%d %d\n", a, b);
  return 0;
}
</pre>
</div>

<p>
对于这个例子，它的关键点是 <code>swap</code> 函数，为什么在函数里已经交换了变量，但输出的结果却和输入一样呢？<br />
原因已经在语法里说过，函数内的变量并不是从函数外进入的变量，函数内的变量只是复制了他的值，所以你无论在函数内做什么操作，都不会影响到函数外的变量。<br />
那我们怎么办呢？<br />
现在又到指针登场的环节了<br />
</p>

<div class="org-src-container">
<pre class="src src-c">#include &lt;stdio.h&gt;

void swap(int *a, int *b) {
  int temp = *a;
  *a = *b;
  *b = temp;
}

int main() {
  int a, b;
  scanf("%d %d", &amp;a, &amp;b);
  swap(&amp;a, &amp;b);
  printf("%d %d\n", a, b);
  return 0;
}
</pre>
</div>

<p>
可以看到我把两个指针作为参数，然后我把 <code>a</code> <code>b</code> 的地址传入了函数，这样虽然只把值复制了过去，但我们已经知识了地址，所以直接修改地址指针的内存即可。<br />
</p>
</div>
</div>
</div>

<div id="outline-container-org47dc3e6" class="outline-3">
<h3 id="org47dc3e6">递归</h3>
<div class="outline-text-3" id="text-org47dc3e6">
</div>
<div id="outline-container-org75f165a" class="outline-4">
<h4 id="org75f165a">简介</h4>
<div class="outline-text-4" id="text-org75f165a">
<p>
首先，我们可以确定一点，函数内是可以使用函数的，这点一开始就可以从在 <code>main</code> 函数内使用 <code>printf</code> 看出。<br />
那么你有没有想过，如果我在函数内使用自己会怎么样呢？<br />
可以预见，没有特殊措施的话，程序会疯狂的循环<br />
但只要函数有最小值，并且每次递归时输入的规模都会减少，这个函数还是会停止的<br />
</p>
</div>
</div>
<div id="outline-container-orge5d913a" class="outline-4">
<h4 id="orge5d913a">fib</h4>
<div class="outline-text-4" id="text-orge5d913a">
<p>
对于fib数列，它在数学是这样定义的<br />
</p>
\begin{equation}
fib(n)=\left\{
\begin{array}{cc}
0 & {n=0}\\
1 & {n=1}\\
1 & {n=2}\\
fib(n-1)+fib(n-2) & {n>2}
\end{array}
\right.
\end{equation}

<p>
可以看到上面是 <code>fib</code> 函数的定义，我们只需要把它转换成 <code>c</code> 的形式即可<br />
</p>

<div class="org-src-container">
<pre class="src src-c">#include &lt;stdio.h&gt;

int fib(int n) {
  if (n == 0)
    return 0;
  if (n &lt; 2)
    return 1;
  return fib(n - 1) + fib(n - 2);
}

int main() {
  int n;
  scanf("%d", &amp;n);
  printf("%d\n", fib(n));
  return 0;
}
</pre>
</div>

<p>
从这个例子可以看出对于数学上的东西，使用递归是最好写的，但这也说明了，理解需要一定的数学思维，毕竟现实世界上人可不能把自己提起来。<br />
</p>

<p>
为什么函数自己调用自己时不会产生混乱呢？<br />
因为 <code>c</code> 每次执行函数时，都是新生成了一个机器。如果我们把函数定义比做一张蓝图，那么执行函数时我们就制作了一个机器来运行，也就是每次执行的函数都是一个全新的机器，我在这台机器做的操作当然不会同步到另一台机器，而之前的一台机器也会耐心等待后面的机器运行完毕后，再把返回的结果拿过来。<br />
</p>
</div>
</div>
</div>

<div id="outline-container-org53fd7b3" class="outline-3">
<h3 id="org53fd7b3">结构体</h3>
<div class="outline-text-3" id="text-org53fd7b3">
</div>
<div id="outline-container-org8ec4c7e" class="outline-4">
<h4 id="org8ec4c7e">简介</h4>
<div class="outline-text-4" id="text-org8ec4c7e">
<p>
结构体提供了一个把多种类型，多个变量集合到一起的功能<br />
比如我想保存一个学生的数据，对于学生他有年龄、名字、学号、性别...<br />
我们当然可以直接定义多个变量，但如果我想把这些数据传入函数处理，那么就要输入很多变量，而如果我想返回一个学生的数据，那我们只能使用丑陋又危险的全局变量了<br />
或者，我们可以简单的使用结构体来解决这些问题<br />
</p>
</div>
</div>
<div id="outline-container-orga93dfa4" class="outline-4">
<h4 id="orga93dfa4">语法</h4>
<div class="outline-text-4" id="text-orga93dfa4">
<p>
结构体其实是声明了一个类型，很奇怪吧，我们之前声明过很多东西，但没想到类型也可以自定义吧<br />
类型就意味着，使用结构体时，我们是使用一个结构体类型的变量<br />
下面我们就直接来看代码<br />
</p>

<div class="org-src-container">
<pre class="src src-c">#include &lt;stdio.h&gt;

/* 定义了一个结构体类型stu */
struct stu {
  /* 学号和年龄 */
  int no, age;
  /* 性别和名字 */
  char sex, name[20];
};

void prtstu(struct stu a) {
  printf("学号：%d 年龄：%d 性别：%c 名字：%s\n", a.no, a.age, a.sex, a.name);
}

int main() {
  /* struct表示它是一个结构体类型 */
  struct stu xiami;
  /* 使用.运算符可以使用结构体内的变量 */
  scanf("%d %d %c %s", &amp;xiami.no, &amp;xiami.age, &amp;xiami.sex, xiami.name);
  prtstu(xiami);
  return 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org513c236" class="outline-4">
<h4 id="org513c236">结构体指针</h4>
<div class="outline-text-4" id="text-org513c236">
<p>
我们来看一个很魔鬼的东西，结构体指针<br />
顾名思义，结构体指针就是存放着结构体变量地址的变量<br />
使用 <code>struct stu *p</code> 就定义了一个学生类型的结构体指针， <code>p</code> 可以指向一个结构体变量的地址了<br />
现在我们再声明一个结构体变量 <code>struct stu a</code> ，把 <code>p</code> 指向这个变量 <code>p = &amp;a</code><br />
现在我们想知道a的年龄就可以这样 <code>(*p).age</code><br />
因为 <code>.</code> 的优先级高于 <code>*</code> 所以必须用一个括号括起来<br />
这个方式太过麻烦，跟不用 <code>[]</code> 的数组一样，那么官方有没有做一个对应的语法糖呢？<br />
幸运的是还真有，使用 <code>-&gt;</code> 即可， <code>p-&gt;ag</code> 就可以查看 <code>a</code> 的年龄了<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org1a02f6c" class="outline-2">
<h2 id="org1a02f6c">C++</h2>
<div class="outline-text-2" id="text-org1a02f6c">
</div>
<div id="outline-container-org17ea410" class="outline-3">
<h3 id="org17ea410">stl</h3>
<div class="outline-text-3" id="text-org17ea410">
<p>
<code>c++</code> 是 <code>c</code> 的超集，也就是说 <code>c++</code> 支持所有 <code>c</code> 的语法，并在此基础上 <code>c++</code> 又新增了一些语法与工具。更重要的区别在于 <code>c</code> 是面向过程的，而 <code>c++</code> 是面向对象的。<br />
</p>

<p>
对于我们做算法竞赛的同学来说， <code>c++</code> 最重要的功能就是 <code>stl</code> 了，它内置了许多有用的工具，这使得我们不需要一切都从轮子写起。<br />
</p>

<p>
<code>namespace</code> 即命名空间，不同于 <code>c</code> 在 <code>c++</code> 里提供了一种分隔代码的好方法，我们可以为一类变量函数增加一个命名空间，使用 <code>空间名::变量名</code> 就可以使用这个命名空间内的东西， <code>stl</code> 就是这样做的，它为每个变量与函数都设置了名为 <code>std</code> 的命名空间。但这个东西其实非常的麻烦，每个函数我都要加上5个字符，所以可以使用 <code>using namespace std;</code> 来导入这个命名空间，让它所有的变量与函数暴露出来。<br />
</p>

<p>
但这也引出了一个问题， <code>std</code> 下的内容太多了，像 <code>min</code> 、 <code>max</code> 、 <code>next</code> 、 <code>count</code> 等等常用的名字都被使用了，所以我们必须避开他们，使用其它的名字。<br />
</p>
</div>
</div>
<div id="outline-container-org0b9dde2" class="outline-3">
<h3 id="org0b9dde2">输入输出</h3>
<div class="outline-text-3" id="text-org0b9dde2">
</div>
<div id="outline-container-orgc5269a9" class="outline-4">
<h4 id="orgc5269a9">头文件</h4>
<div class="outline-text-4" id="text-orgc5269a9">
<p>
<code>c++</code> 的输入输出头文件叫 <code>iostream</code> ，引用使用 <code>#include &lt;iostream&gt;</code> 语句<br />
</p>

<p>
可以发现，头文件后面并没有 <code>.h</code> ，这是 <code>c++</code> 与 <code>c</code> 的不同，所有新增的头文件都不能加 <code>.h</code><br />
</p>
</div>
</div>
<div id="outline-container-orgcaf478f" class="outline-4">
<h4 id="orgcaf478f">cin</h4>
<div class="outline-text-4" id="text-orgcaf478f">
<p>
使用 <code>cin &gt;&gt; 变量名</code> 可以从标准输入把数据输入变量内，需要注意的是输入时不需要加标识符来表示变量的类型， <code>c++</code> 可以自己确定变量的类型，并根据类型自己确定会输入的数据。<br />
</p>

<p>
<code>cin &gt;&gt; 变量名1 &gt;&gt; 变量名2 &gt;&gt; 变量名3</code> 它的后面可以接许多个变量，变量的输入是从左至右依次进行， <code>&gt;&gt;</code> 可以把想像成数据流入了变量。<br />
</p>
</div>
</div>
<div id="outline-container-org29c2c53" class="outline-4">
<h4 id="org29c2c53">cout</h4>
<div class="outline-text-4" id="text-org29c2c53">
<p>
同理 <code>cout &lt;&lt; 表达式</code> 就可以向标准输出输出内容了， <code>cout</code> 也会自动判断表达式返回值的类型，但相比 <code>printf</code> 它就不能做到精准的格式输出了，比如固定4位宽度的数字使用 <code>cout</code> 就比较难以做到了。<br />
</p>
</div>
</div>
<div id="outline-container-org226f1cb" class="outline-4">
<h4 id="org226f1cb">总结</h4>
<div class="outline-text-4" id="text-org226f1cb">
<p>
对于输入没有规定必须使用哪个，挑选最合适的就行了。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgd1852ed" class="outline-3">
<h3 id="orgd1852ed">vector</h3>
<div class="outline-text-3" id="text-orgd1852ed">
</div>
<div id="outline-container-orge91833c" class="outline-4">
<h4 id="orge91833c">头文件</h4>
<div class="outline-text-4" id="text-orge91833c">
<p>
<code>#include &lt;vector&gt;</code><br />
</p>
</div>
</div>
<div id="outline-container-org92b7735" class="outline-4">
<h4 id="org92b7735">简介</h4>
<div class="outline-text-4" id="text-org92b7735">
<p>
<code>vector</code> 翻译成中文叫向量<br />
它可以理解成一个动态数组，它的长度可以自由调整<br />
</p>
</div>
</div>
<div id="outline-container-orgfe9e662" class="outline-4">
<h4 id="orgfe9e662">创建</h4>
<div class="outline-text-4" id="text-orgfe9e662">
<p>
<code>vector&lt;类型名&gt; 数组名</code> 就可以创建一个 <code>vector</code> 了<br />
不止如此， <code>vector</code> 支持初始化时自定义长度与初始内容<br />
<code>vector&lt;int&gt; v1(3)</code> 创建了长度为3，元素默认值为0的 <code>vector</code><br />
<code>vector&lt;int&gt; v2(5, 10)</code> 创建了长度为5，元素默认值为10的 <code>vector</code><br />
<code>vector&lt;int&gt; v3(v1)</code> 创建了和 <code>v1</code> 内容一样的 <code>vector</code><br />
</p>
</div>
</div>
<div id="outline-container-org667ec81" class="outline-4">
<h4 id="org667ec81">使用</h4>
<div class="outline-text-4" id="text-org667ec81">
<p>
可以直接使用 <code>[]</code> 像数组一样访问 <code>vector</code><br />
<code>vector</code> 因为是一个对象，它内置了一系列函数，其中有一个名为 <code>at()</code> 的函数也可以访问对应下标的元素，但如果下标越界了它会直接抛出异常<br />
</p>

<p>
下面我介绍几个常用的函数：<br />
<code>size()</code> 返回向量的长度<br />
<code>empty()</code> 如果向量为空则返回真<br />
<code>begin()</code> 返回向量第一个元素的引用（地址）<br />
<code>end()</code> 返回向量最后一个元素之后一个长度的引用<br />
<code>push_back()</code> 在向量后面加入一个元素<br />
<code>pop_back()</code> 删除向量最后一个元素<br />
<code>insert()</code> 在某个位置插入元素<br />
</p>

<p>
<code>vector</code> 也重载了一些运算符<br />
使用 <code>v1=v2</code> 可以直接赋值<br />
使用 <code>v1==v2</code> 可以轻松的判断两个向量是否完全一致<br />
使用 <code>v1&gt;v2</code> 可以判断两个向量的大小问题，它从第一个元素开始对比，如果当前 <code>v1</code> 元素不等于 <code>v2</code> 直接返回它们之间的大小，如果相等就同时向后延一格对比<br />
</p>
</div>
</div>
</div>

<div id="outline-container-org08b29e5" class="outline-3">
<h3 id="org08b29e5">string</h3>
<div class="outline-text-3" id="text-org08b29e5">
</div>
<div id="outline-container-org23b7495" class="outline-4">
<h4 id="org23b7495">头文件</h4>
<div class="outline-text-4" id="text-org23b7495">
<p>
<code>#include &lt;string&gt;</code><br />
</p>
</div>
</div>
<div id="outline-container-orged7dc94" class="outline-4">
<h4 id="orged7dc94">简介</h4>
<div class="outline-text-4" id="text-orged7dc94">
<p>
<code>string</code> 是一个字符串，它的底层实现是 <code>vector</code> 它可以使用 <code>vector</code> 的所有函数，它也新加了许多方便的方法<br />
</p>
</div>
</div>
<div id="outline-container-orga84c4c9" class="outline-4">
<h4 id="orga84c4c9">使用</h4>
<div class="outline-text-4" id="text-orga84c4c9">
<p>
它的创建方法与 <code>vector</code> 一样，这些可以直接看上面的 <code>vector</code> 介绍<br />
</p>

<p>
对于字符串来说它有两个方法非常常用<br />
<code>find()</code> 可以查找子串第一次出现的位置，函数可以传入字符或字符串<br />
<code>substr(pos, len)</code> 从 <code>pos</code> 开始开始截取 <code>len</code> 个字符并返回它<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org9312bbb" class="outline-3">
<h3 id="org9312bbb">queue</h3>
<div class="outline-text-3" id="text-org9312bbb">
</div>
<div id="outline-container-org5970941" class="outline-4">
<h4 id="org5970941">头文件</h4>
<div class="outline-text-4" id="text-org5970941">
<p>
<code>#include &lt;queue&gt;</code><br />
</p>
</div>
</div>
<div id="outline-container-org08ebaa5" class="outline-4">
<h4 id="org08ebaa5">简介</h4>
<div class="outline-text-4" id="text-org08ebaa5">
<p>
<code>queue</code> 叫做队列，它是一种数据结构，先进入队列的数据会先出来，可以想像一个管子，从后面往里面塞球，取球时只能从前面取<br />
</p>

<p>
还有一个叫双端队列的类 <code>deque</code> ，与 <code>queue</code> 的不同在于， <code>deque</code> 可以从两边取和删除数据<br />
</p>

<p>
为什么要使用队列呢？我使用数组也可以做到相同功能<br />
原因就是数组在前端插入一个数据需要遍历整个数组，但队列只需要一下操作就能实现，这在数据量大的情况下是有利的。<br />
简单来说 <code>queue</code> 的修改是 <code>O(1)</code> 的，而数组的修改是 <code>O(n)</code> 的。<br />
</p>
</div>
</div>
<div id="outline-container-orgfedbe79" class="outline-4">
<h4 id="orgfedbe79">使用</h4>
<div class="outline-text-4" id="text-orgfedbe79">
<p>
<code>queue&lt;类型名&gt; 队列名</code> 就可以创建一个队列了，初始化的方法与之前的方法一致<br />
</p>

<p>
<code>queue</code> 的函数：<br />
<code>empty()</code> 返回队列是否为空<br />
<code>push()</code> 向队尾插入一个元素<br />
<code>pop()</code> 队首弹出一个元素<br />
<code>front()</code> 查看队首的元素<br />
</p>

<p>
<code>deque</code> 的函数：<br />
<code>push_front()</code> 在队首插入元素<br />
<code>pop_front()</code> 弹出队首的元素<br />
<code>push_back()</code> 在队尾插入元素<br />
<code>pop_back()</code> 弹出队尾的元素<br />
<code>at()</code> 通过下标访问元素<br />
</p>
</div>
</div>
</div>

<div id="outline-container-org3640569" class="outline-3">
<h3 id="org3640569">stack</h3>
<div class="outline-text-3" id="text-org3640569">
</div>
<div id="outline-container-org6e927e2" class="outline-4">
<h4 id="org6e927e2">头文件</h4>
<div class="outline-text-4" id="text-org6e927e2">
<p>
<code>#include &lt;stack&gt;</code><br />
</p>
</div>
</div>
<div id="outline-container-org6f38381" class="outline-4">
<h4 id="org6f38381">简介</h4>
<div class="outline-text-4" id="text-org6f38381">
<p>
<code>stack</code> 是栈，与队列相反，栈只能在一端插入或删除，就像一个筒装薯片一样，你可以在开口处拿薯片或放入薯片，可以发现栈的元素是后进先出的。<br />
</p>

<p>
我们的递归函数底层使用了栈，有时写算法题时直接使用递归可能会爆内存，这时可以使用栈来模拟递归。<br />
</p>
</div>
</div>
<div id="outline-container-org9607100" class="outline-4">
<h4 id="org9607100">使用</h4>
<div class="outline-text-4" id="text-org9607100">
<p>
<code>stack&lt;类型名&gt; 栈名</code> 与之前初始化一样的方法<br />
</p>

<p>
<code>stack</code> 的函数主要有：<br />
<code>back()</code> 获取尾部元素<br />
<code>push_back()</code> 向尾部推入一个元素<br />
<code>pop_back()</code> 从尾部弹出一个元素<br />
</p>

<p>
可以发现，使用 <code>deque</code> 可以模拟 <code>stack</code><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org8138938" class="outline-3">
<h3 id="org8138938">set</h3>
<div class="outline-text-3" id="text-org8138938">
</div>
<div id="outline-container-orgc8f6e10" class="outline-4">
<h4 id="orgc8f6e10">头文件</h4>
<div class="outline-text-4" id="text-orgc8f6e10">
<p>
<code>#include &lt;set&gt;</code><br />
</p>
</div>
</div>
<div id="outline-container-orgf130e0f" class="outline-4">
<h4 id="orgf130e0f">简介</h4>
<div class="outline-text-4" id="text-orgf130e0f">
<p>
<code>set</code> 是集合，和数学上的集合一样，每个元素只能出现一次，这对于统计有多少个不同的元素是很方便的。<br />
</p>

<p>
顺便说一句， <code>set</code> 的复杂度都 <code>O(logN)</code> 的，它的底层实现是红黑树<br />
</p>
</div>
</div>
<div id="outline-container-org9190f48" class="outline-4">
<h4 id="org9190f48">使用</h4>
<div class="outline-text-4" id="text-org9190f48">
<p>
<code>set&lt;类型名&gt; 集合名</code> 创建一个 <code>set</code><br />
</p>

<p>
<code>set</code> 的函数有：<br />
<code>insert()</code> 插入一个元素<br />
<code>erase()</code> 删除元素<br />
<code>clear()</code> 清空集合<br />
<code>find()</code> 在集合内查找元素，并返回它在集合内的引用<br />
<code>count()</code> 统计元素在集合内的个数，它的返回值只能是1或0<br />
<code>empty()</code> 返回集合是否为空<br />
<code>size()</code> 集合的元素个数<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orgddf2b1a" class="outline-3">
<h3 id="orgddf2b1a">map</h3>
<div class="outline-text-3" id="text-orgddf2b1a">
</div>
<div id="outline-container-orgef72671" class="outline-4">
<h4 id="orgef72671">头文件</h4>
<div class="outline-text-4" id="text-orgef72671">
<p>
<code>#include &lt;map&gt;</code><br />
</p>
</div>
</div>
<div id="outline-container-org83c2a0c" class="outline-4">
<h4 id="org83c2a0c">简介</h4>
<div class="outline-text-4" id="text-org83c2a0c">
<p>
<code>map</code> 的意思其实是映射，它可以保存 <code>key</code> 到 <code>value</code> 的映射，也就是键值对<br />
说人话，就像数组可以通过下标访问元素， <code>map</code> 也是通过 <code>key</code> 访问元素，不同于数组 <code>map</code> 的 <code>key</code> 可以是数字、字符、字符串等等<br />
一个 <code>key</code> 只能映射到一个 <code>value</code><br />
</p>

<p>
<code>map</code> 的复杂度也都是 <code>O(logN)</code><br />
</p>
</div>
</div>
<div id="outline-container-org08467af" class="outline-4">
<h4 id="org08467af">使用</h4>
<div class="outline-text-4" id="text-org08467af">
<p>
<code>map&lt;键类型, 值类型&gt; 映射名</code> 可以创建一个 <code>map</code> 需要标注好键和值的类型<br />
</p>

<p>
使用方法和数组类似 <code>map1[键]</code> 就可以返回对应键的值了<br />
</p>

<p>
比如 <code>map&lt;char, int&gt; m</code> 创建了名为 <code>m</code> 的映射，它可以把一个字符映射到一个整数数字上<br />
<code>m['a'] = 100</code> 就把100保存到a这个键内了<br />
<code>m['a']</code> 对这个表达式求值就返回100了<br />
</p>

<p>
<code>map</code> 的函数：<br />
<code>count()</code> 统计一个键的数量<br />
<code>find()</code> 返回对应键在映射内的指针<br />
<code>size()</code> 返回全部元素个数<br />
<code>empty()</code> 返回映射是否为空<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org653cca2" class="outline-3">
<h3 id="org653cca2">sort</h3>
<div class="outline-text-3" id="text-org653cca2">
</div>
<div id="outline-container-orga28bde7" class="outline-4">
<h4 id="orga28bde7">头文件</h4>
<div class="outline-text-4" id="text-orga28bde7">
<p>
<code>#include &lt;algorithm&gt;</code><br />
</p>

<p>
这个头文件内有许多算法的实现，比如等下要讲的排序<br />
</p>
</div>
</div>
<div id="outline-container-orgb41477a" class="outline-4">
<h4 id="orgb41477a">简介</h4>
<div class="outline-text-4" id="text-orgb41477a">
<p>
<code>sort</code> 是排列的意思，它可以对给定范围内的数据进行排序，传入一个比较函数就可以控制是从小到大还是从大到小排序了。<br />
</p>

<p>
<code>sort</code> 排列的复杂度是 <code>O(n*logN)</code><br />
</p>
</div>
</div>
<div id="outline-container-orgb6d4f20" class="outline-4">
<h4 id="orgb6d4f20">用法</h4>
<div class="outline-text-4" id="text-orgb6d4f20">
<p>
<code>sort(起始引用,未尾引用)</code> 就可以对这个范围内的数据排序了，需要注意未尾引用是最后一个元素的引用加1<br />
</p>

<p>
不需要指定被排序数据的类型， <code>sort</code> 会自动判断<br />
可以为第三个参数添加一个比较函数，让 <code>sort</code> 使用这个函数的规则排序<br />
</p>

<div class="org-src-container">
<pre class="src src-c++">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

bool cmp1(int a, int b) { return a &gt; b; }

int main() {
  vector&lt;int&gt; a = {9, 6, 3, 8, 5, 2, 7, 4, 1, 0};
  sort(a.begin(), a.end());
  for (int i = 0; i &lt; a.size(); i++)
    cout &lt;&lt; a[i] &lt;&lt; " ";
  cout &lt;&lt; endl;

  sort(a.begin(), a.end(), cmp1);
  for (int i = 0; i &lt; a.size(); i++)
    cout &lt;&lt; a[i] &lt;&lt; " ";
  cout &lt;&lt; endl;

  int b[] = {9, 6, 3, 8, 5, 2, 7, 4, 1, 0};
  sort(b, b + 10);
  for (int i = 0; i &lt; 10; i++)
    cout &lt;&lt; b[i] &lt;&lt; " ";
  cout &lt;&lt; endl;

  sort(b, b + 10, cmp1);
  for (int i = 0; i &lt; 10; i++)
    cout &lt;&lt; b[i] &lt;&lt; " ";
  cout &lt;&lt; endl;
  return 0;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgc2b3c1b" class="outline-3">
<h3 id="orgc2b3c1b">next_permutation</h3>
<div class="outline-text-3" id="text-orgc2b3c1b">
</div>
<div id="outline-container-org7c1432f" class="outline-4">
<h4 id="org7c1432f">头文件</h4>
<div class="outline-text-4" id="text-org7c1432f">
<p>
<code>#include &lt;algorithm&gt;</code><br />
</p>
</div>
</div>
<div id="outline-container-org090dc9d" class="outline-4">
<h4 id="org090dc9d">简介</h4>
<div class="outline-text-4" id="text-org090dc9d">
<p>
<code>next_permutation</code> 可以生成一个范围内数据的下一个排列<br />
比如 <code>1 2 3</code> 的下一个排列就是 <code>1 3 2</code><br />
这个函数的作用是非常大的，以后做有些算法题时，如果不想用递归写 <code>dfs</code> 可以使用这个函数解决<br />
</p>

<p>
比如有一些人想接水，每个人接水的时间不同，我们想让所有人的等待时间之和最小，使用暴力的方法，把这些人的每种排列情况都算一遍就能得到答案了，当然这道题使用其它的方法更简单<br />
</p>
</div>
</div>
<div id="outline-container-org7675c44" class="outline-4">
<h4 id="org7675c44">使用方法</h4>
<div class="outline-text-4" id="text-org7675c44">
<p>
<code>next_permutation(起始引用,未尾引用)</code> 会生成范围内的下一个排列，如果不能生成了就返回 <code>false</code><br />
</p>

<div class="org-src-container">
<pre class="src src-c++">#include &lt;algorithm&gt;
#include &lt;iostream&gt;

using namespace std;

int main() {
  int all[] = {1, 2, 3, 4, 5};
  do {
    for (int i = 0; i &lt; 5; i++)
      cout &lt;&lt; all[i] &lt;&lt; " ";
    cout &lt;&lt; endl;
  } while (next_permutation(all, all + 5));
  return 0;
}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orga806ca7" class="outline-2">
<h2 id="orga806ca7">结语</h2>
<div class="outline-text-2" id="text-orga806ca7">
<p>
这篇文章只讲解了 <code>C/C++</code> 的一下部分内容，如果你对其它的部分也感兴趣的话，我推荐一本书 《C++ Prime Plus》<br />
</p>
</div>
</div>

</div>
</div>

        <div>
      <div class="post-meta">
        <span title="post date" class="post-info">2020-11-17</span>
        <span title="last modification date" class="post-info">2020-12-11</span>
        <span title="tags" class="post-info"><a href="/tags/tutorial/">tutorial</a>, <a href="/tags/c-c++/">C/C++</a></span>
        <span title="author" class="post-info">lampze</span>
      </div>
      <section>
        <h1>Comments</h1>
      </section>
      <script src="//code.jquery.com/jquery-latest.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.js"></script>
      <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script src="/media/js/main.js"></script>
      <div class="footer">
        <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 28.x (<a href="http://orgmode.org">Org mode</a> 9.x)</p>
        <p>
          Copyright &copy; 2012 - <span id="footerYear"></span> <a href="mailto:1229408499 &lt;at&gt; qq &lt;dot&gt; com">lampze</a>
          &nbsp;&nbsp;-&nbsp;&nbsp;
          Powered by <a href="https://github.com/kelvinh/org-page" target="_blank">org-page</a>
          <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
        </p>
      </div>
    </div>

  </body>
</html>
