#+TITLE:       基础算法简介
#+DATE:        <2021-01-08 00:00>
#+FILETAGS:    algorithm
#+OPTIONS:     H:3 num:nil toc:t \n:t ::t |:t ^:nil -:nil f:t *:t <:t
#+DESCRIPTION: 介绍竞赛常用的基础算法
* 前言
本文将会简单介绍些竞赛会使用的各种算法

学习算法之前是需要一点编程语言基础的，在学习算法时就需要确定一门实现语言了，对于初学者我还是推荐使用 =C++= 或者 =Python= 。因为 =C++= 多了许多有用的算法库，而不需要像 =C= 那样关心底层， =Python= 则是完全不用考虑许多细节，可以更加专注于算法思维。
* 算法思想
** 模拟
模拟的含义就是题目说什么我们就做什么，比如赛跑、算时间、猜拳等等只需要根据题意把代码实现出来即可
模拟是我们拿到一个题目时第一个思考的破解算法，但对于大多数题目单纯的模拟是不能在规定时间内解开的。也有的题目只能使用模拟，但模拟的事物非常复杂，这时就非常考验编程功底了。

可以这样说，其它算法思想的出现解决了不能直接模拟的问题。
** 搜索
搜索即是找到答案的过程，通过题目上已知的可能解，我们一个一个的去试就能找到正确的解了。

比如题目给定了一些数，问两个数和为0的数对有多少。

我们可以使用两个循环，每个循环确定一个数，就可以把所有的可能性都遍历了。

当然有些题目是不能简单的直接使用固定的循环的，比如我把那个题目改成和为0的子集数量，就不可能使用2个3个或者4个循环解决了。
** 递归
递归既调用自身

我们会遇到一些公式，它们会自己引用自己，像 =fib(n)=fib(n-1)+fib(n-2)= ，当然只有这一条的公式是不可解的，它还需要一个下界 =fib(1)=fib(2)=1= 。

这时我们从 =fib(n)= 开始算起的过程就叫递归，虽然我们人这样算时非常痛苦，需要记录很多中间变量，但机器天然就适应这样的算法，只需要几行代码就能实现。

#+begin_src C++
int fib(int n) {
  if (n <= 2)
    return 1;
  return fib(n - 1) + fib(n - 2);
}
#+end_src
** 递推
递推与递归相反，递推也是使用相同的数学公式，但它从下界开始算起，比如算 =fib(n)= 使用递推的思想就是从 =fib(1)= 开始一步一步往上推。

#+begin_src C++
int fib(int n) {
  int f[n + 1] = {0, 1, 1};
  for (int i = 3; i <= n; i++)
    f[i] = f[i - 1] + f[i - 2];
  return f[n];
}
#+end_src

可以发现这种做法更加贴近人的思维，并且使用普通的循环就解决了问题，但作为代价我们需要推算出所有的上下界，并准确的处理这些边界情况。

有些同学可能发现了递推的版本使用了数组，而递归的版本没有，这是否说明递推的方法需要消耗更多的内存呢？
其实并没有，递归的代码需要多次调用函数，每次调用的函数都会消耗空间，但递推我们申请内存只能规整的一块一块同时申请，但递归的空间使用情况是动态的，虽然最大时的空间消耗相同，但我认为动态的程序是比较好的。

* 算法种类
** 搜索
搜索的思想已经讲过，下面我介绍一些常用的搜索方法
*** 枚举
简单的把每种可能性都测试一遍，循环即可
*** 排列
对于安排时间的问题：给出很多段时间，要求找到不重合的时间段，使得总时长最大

排列既对给定的时间段排列组合情况都试试，比如一共有3段时间的话就是试试 =1,2,3= 、 =1,3,2= 、 =3,1,2= 、 =3,2,1= 这些情况，注意这里的数字是时间段的下标，即第几个时间段，不止这个题目许多题目都可以使用这个排列顺序解决。

所以我们只要找出生成这个排列的方法就能解决这些问题，可喜可贺的是 =C++= 有一个函数可以生成排列 =next_permutation= ，下面给出一个伪代码。

#+begin_src C++
// time存放时间段，len是时间段的个数
int time[], len;
int per[len];
// 初始化排列数组
for (int i = 0; i < len; i++)
  par[i] = i;
do {
  计算当前排列不重合时间段的总时长并更新最大值
} while (next_permutation(per, per + len));
// next_permutation会计算下一个排列，如果没有的话会返回假
#+end_src

*** 子集
给定一些数，问你一共有多少种方法让数的和为0。

这种情况我们就要遍历所有的子集了，我们还是把数字的下标抽象出来，不关心具体的数，只关心第几个数，我们只需要知道所有数字对应下标的子集即可。
可以肯定对于1到n的集合是有通用的子集生成算法的，就像之前的排列。

因为子集并没有库函数，所以我们只能自己来实现了。

一个数字在集合里只有两种状态：存在或者不存在。我们用1和0表示，像下面这样
#+begin_example
1 2 3
0 0 1
#+end_example
表示这个集合只有3
调整第二行的数字就可以得到所有的子集了，可以知道3个数有8个子集。聪明的同学可能发现了，n个数的集合有 =2^n= 个子集
如果我们把第二行的数字从左至右连接在一起，组合成一个二进制数。像上面这个例子就是 =001= 这个二进制数，我们只需要从 =000= 开始每次增加1，直到 =111= 就能得到所有的子集
现在很清晰了，从0开始遍历到 =2^n= 即可，每次找到对应2进制位为1的下标就是当前子集存在的数。

#+begin_src C++
// num是所有数字，len是数字个数
int num[], len, cou = 0;
// 1 << len的结果是2^len
for (int i = 0; i < (1 << len); i++) {
  int sum = 0, ind = 0, temp = i;
  // 遍历第一位
  while (temp) {
    // 如果当前位为1表示当前下标的数字存在于子集
    if (temp % 2)
      sum += num[ind];
    ind++;
    temp /= 2;
  }
  if (sum == 0)
    cou++;
}
#+end_src

*** DFS
DFS(Depth First Search)既深度优先搜索

用生成排列的问题来举例的话，可以想像出10个空位，每个空位都可以放数字， =DFS= 就是优先把空位都填好。

#+begin_src C++
int end = 10;
int num[end];

void dfs(int now) {
  // 全部空位都填完了
  if (now == end) {
    for (int i = 0; i < end; i++)
      cout << num[i] << " ";
    cout << endl;
    return;
  }
  // 列出所有可填的数字
  for (int i = 1; i <= end; i++) {
    // 填当前位置
    num[now] = i;
    // 填完立即去填下一个
    dfs(now + 1);
  }
}
#+end_src

这个代码会填入重复的数字，同学们可以自己修改试试

*** BFS
BFS(Breadth First Search)既广度优先搜索

与 =DFS= 不同， =BFS= 是先把当前空位的所有可能数字都填好后再进入下一个格子，所以 =BFS= 还需要保存所有的状态，一般采用队列的方式保存。
*** 二分查找
二分查找只能应用在有单调性的数据上，对于一个单调递增的数列，我想查找一个数字是否存在于这个数列上，就可以查找数列中间的数字，如果相等返回真，如果查找的数字比中间数字大就去右边查找，反之则去左边查找。
** 动态规划
动态规划是算法学习上的一道分水岭，动态规划的核心是找出题目背后的那个数学公式，而找到公式是非常困难的，所幸有许多类型的题目都有现成的公式，而找到公式后就可以非常简单轻松的完成了。
*** 递推
递推与之前讲的内容一样，利用公式从小的情况开始出发，处理好边界情况，慢慢的向上递推到目标

递推时虽然时间复杂度是一致的，但空间复杂度还可以优化，有许多公式不会用到非常以前的结果，我们就可以节省掉这些空间，比如 =fib= 的例子我们只需要2个变量保存历史结果。
*** 记忆化搜索
因为对于复杂的公式，递推有时非常的难以确定边界，而公式一般都是递归的，我们可以直接使用递归完成题目，但时间复杂度会爆炸，因为有许多子问题是重复的，使用递归会重复计算这些内容，所以我们可以利用空间换取时间，既记录已经算过的结果，保存下来以便以后使用，这样就能在相同的时间复杂度下完成了。
*** 贪心
有些最优子结构的题目可以不使用动态规划的方法解决，单纯的最大或最小就能解决，这里只需要排序即可，但分辩这些题目是最大的难点。
** 数学
*** 高精度
=C++= 的数字是有范围的，超过一定大小就会损失精度，这时可以自己模拟数字的计算来实现高精度的数字计算。
可以使用数组保存每一位的数字，然后利用平常计算加减乘除的方法就能解决了，当然这样模拟的程序是非常复杂的。

=Java= 与 =Python= 都自带有高精度的解决方案
*** 快速幂
如何快速计算 $a^b$ ，普通的做就是使用循环一个一个相乘，这样的时间复杂度为 $O(b)$ ，可以把 $a^b=$ 分成三个部分 $a^{b/2}*a^{b/2}*a$ 如果 =b= 是偶数则没有最后一个 =a= ，可以发现有两个相同的数，所以我们可以重复利用 $a^{b/2}$ ，这样最后的复杂度只有 $O(log(b))$

#+begin_src C++
int pow(int a, int b) {
  if (b == 0)
    return 1;
  int c = pow(a, b / 2);
  if (b % 2)
    return c * c * a;
  return c * c;
}
#+end_src
*** 数论
想把数论学好，需要非常好的数学功底，但基础的题目还是非常简单的，只需要记下公式与用法即可。

基础的部分有埃氏筛法、最大公约数、最小公倍数、乘法的逆元、同余方程等
** 数据结构
数据结构是为了更好更快的实现特定的算法
*** 栈
栈是个存储容器，它的数据出入顺序是先入后出，可以自己使用数组模拟，但 =stl= 有集成。

函数的递归调用就是使用栈来实现的。
*** 队列
队列也是一个存储窗口，它的出入顺序先入选出，就像是一根管子或者排队打饭。

使用这些存储容器是为了解决数组的效率问题，更改数组的元素的复杂度基本都是 $O(n)$ 的，但对于队列和栈都是 $O(1)$ 既常数级别的，对于某些特定场景非常的有用，比如约瑟夫问题。
*** 并查集
并查集可以查找一个元素是否在一个集合内，并且可以非常快速的合并两个集合
*** 树状数组
树状数组是对于前缀和问题的时间和空间上的一个平衡，单纯的前缀和需要 $O(1)$ 的时间和 $O(n)$ 的空间，使用树状数组保存前缀和可以做到 $O(log(n))$ 的时空复杂度。

而前缀和可以在常数时间内算出连续范围的内的和，用处非常广泛。
*** 线段树
线段树是树状数组的升级，线段树不止支持区间和，还支持单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作，并且时间复杂度都是 $O(log(N))$ 。

作为代价，线段树的实现非常的复杂，有许多边界条件需要记忆与解决，一不小心就会写错。
** 图论
*** 最短路
最短路就是给定一个图，计算两个结点之间的最短路径。

相应的算法主要有 =Floyd= 、 =Bellman-Ford= 、 =Dijkstra= 、 =Johnson= 等。

每种算法都有各自的优点与适用的题型，最好都钻研清楚。
*** 最小生成树
最小生成树是在图上找到一棵子树连接全部节点并且使得边权和最小。

在现实中的计算机网络上，路由器就使用了这个算法。

主要有 =Kruskal= 与 =Prim= 算法，应用了贪心的想法，并且 =Kruskal= 需要使用并查集来处理。
*** 拓扑排序
拓扑排序的目标是将所有节点排序，使得排在前面的节点不能依赖于排在后面的节点。

每次在图上找到一个没有其它节点依赖的节点，移除它和它所有的边，重复这个操作即可。
