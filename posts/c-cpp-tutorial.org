#+TITLE:       C/C++简明教程
#+DATE:        <2020-11-17 00:00>
#+FILETAGS:    tutorial C/C++
#+OPTIONS:     H:3 num:nil toc:t \n:t ::t |:t ^:nil -:nil f:t *:t <:t
#+DESCRIPTION: C/C++的简单教程

* 前言
编程语言是让我们使用一个大部分人能理解的方式控制计算机，所以写代码时最重要的是可读性，对自己要求高的同学可以思考怎么保持代码的整洁与优雅。

本文不会把每种表都列出来（如优先级、关键字等），这些网上或课本上都有，请自行翻阅，本书仅仅是讲清原理与我自己理解的逻辑。

本文只把基础的逻辑与用法讲清楚，最后可能会附带几个例题，想要真正的学会编程还是要多写代码。

如果对更加细节的部分感兴趣，可以看看这些：[[https://www.runoob.com/cprogramming/c-tutorial.html][C 语言教程]]、[[https://github.com/jobbole/awesome-c-cn][awesome-c-cn]]

最后请看看这篇文章《[[https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md][提问的智慧]]》，问问题时请按照这上面做。

* C语言
** 编程与运行流程
*** 写代码
对于 =windows= 来说，我推荐新手使用 =Dev-C++= 这个 =IDE= 来编写代码，这个软件虽然有些年头了，也很长时间没有更新了，但作为一个编程集成环境还是及格的，具体的操作还是比较简单，很多事情都能一键完成。
对于参加蓝桥杯的同学， =Dev-C++= 也是官方指定的编程环境。
请不要使用 =vc++= ！！！

对于 =Linux= 来说，新手可以使用 =nano= 来编写代码，有基础的同学可以学下 =vim= ，进阶的话可以玩玩 =Emacs= 。
*** 编译
对于 =IDE= 来说只需要按下按钮就能自动的编译了，没有什么需要动脑的地方。

当然我们不能这样就行了，下面简单介绍下编译是什么。我们写的代码其实都是文本文件，计算机并不认识，计算机只能处理2进制的指令，也就是机器语言，每种 =CPU= 的机器语言都是不一样的，所以我们需要把我们认识的代码转换成计算机认识机器代码，这个过程叫做编译。

目前使用最广的编译器是 =gcc= ， =Dev-C++= 也是使用的这个编译器，安装 =gcc= 后可以在命令行使用 =gcc= 命令，这个命令给定一个源代码文件，然后输出一个二进制文件，然后计算机就能执行这个二进制文件了。
*** 运行过程
#+begin_src c
#include <stdio.h>

int main() {
  printf("Hello, World\n");
  return 0;
}
#+end_src

对于 =C= 来说，它运行时总会从 =main= 函数开始，只要 =main= 函数结束整个程序就结束了。对于上面这个代码来说，它输出了一行 =Hello，World= 文本，并返回了0。需要注意这个0是返回给了操作系统，作用只有一个，就是告诉操作系统这个程序运行过程是否有错误，0表示没有错误。

注意 =main= 只是第一个执行的函数，定义语句、引入库函数语句、宏语句等肯定是要优先执行的。
** 语法简介
我们从简单的语句开始，语句由表达式组成，一条语句必须有一个分号当作结尾，比如 =1+1;= 就是一条语句。这条语句中的 =+= 是 =C= 自带的一些操作符，数学上常用的运算符都有。这里需要强调一下 === 是赋值运算符，比如 =a=b;= 的意思就是把a的值设置成b的值，也即对等号右边的表达式进行求值，然后把返回值赋值给左边。变量可以简单理解为一个箱子，箱子可以放置或取出数据。

下面讲解表达式，每个表达式都有返回值，同一时刻只能运算一个操作。对于 =1+1+1= 这个表达式，它的求值过程是这样的：
1. 先运算第一个 =1+1= ，它的返回值是 =2=
2. 表达式变成 =2+1=
3. 得出返回值 =3=

记住分辩操作是跟根据操作符来的，有些操作符是需要两边都有数据，有些只需要一个，并且每个操作符都有优先级的，计算机会优先执行优先级高的操作，优先级一般来说符合直觉
如果是同级的操作，根据操作符的类型来判定是从左到右还是从右到左。
如果记不住执行的顺序，可以简单的使用括号把你想要独立执行的操作括起来，括号内的会优先执行。
比如 =(1 + 2) * 3= -> =(3) * 3= -> =3 * 3= -> =9=

这样就是最基本的 =C= 语法，更加复杂的语法在后面讲解。
** 变量
*** 简介
变量可以理解成一个箱子，我们可以把一些东西放到箱子，也可以从箱子内把东西取出来。
类型的作用只是为每个箱子打上了标签，规定了箱子内不能随便放东西，比如一个放水果的箱子就不能把水倒进去。
*** 类型
=C= 是一个强类型的语言，它的意思就是每个数据都有类型，不同类型的数据不能随便使用，比如一个整数类型的变量就不能放入一个小数数据。

=C= 里有三种简单常用的类型：整数、小数、字符；

我们需要记下这些类型的名称
整数有： =short= 、 =int= 、 =long= 、 =long long=
小数有： =float= 、 =doubel=
字符有： =char=

这些不同的类型之间的区别只是它们用来存储数据的空间大小，比如 =short= 只用2个字节存储整数。
对于初学者只需要记下 =int= 、 =float=  、 =char= 就行了。

*** 创建
创建一个变量需要使用变量声明语句，大概是这种形式 =<变量类型> <变量名>;= ，举个例子 =int a;= 这样就创建了一个 =int= 类型的变量 =a= 。

如果使用这种形式 =<变量类型> <变量名> = <表达式>;= 的语句声明变量的话，就会给这个变量一个初始值，比如 =float pi = 3.1415926;= 就定义了一个 =float= 类型的变量 =pi= ，它的初始值为 =3.1415926= 。

注意一点，变量名不能与 =C= 的关键字重名，已经使用过的名字不能重复定义。
*** 使用
在表达式内，我们可以把变量当作一个求值操作，这个操作的返回值为变量内的值，比如 =int a = 1;= 后 =a= 这个表示式的值就为 =1= ， =(a + 1) * a= -> =(1 + 1) * a= -> =2 * a= -> =2 * 1= -> =2= 。

对于变量我们还可以对它使用赋值运算符，比如 === 、 =++= 、 =--= 
=== 就是简单的把等号右边的表示式求值，放到等号左边的变量内
=++= 是把变量内的值加上1，然后放到变量内
=--= 是把变量内的值减去1，然后放入变量内

赋值运算也是一个表示式，这意味着它也会返回一个值
比如 =1 + (a = 3)= -> =1 + 3= -> =4=
需要注意这个表示式会有一个副作用，它把 =a= 的值改变成 =3= 了

后面两个运算符有些许的复杂
=a++= 的返回值是 =a=
=++a= 的返回值是 =a+1=
=a--= 的返回值是 =a--=
=--a= 的返回值是 =a-1=
注意，虽然返回值不一样，但这个变量的值都改变了，也即是一个副作用

下面举些例子 =int a = 1;=
=1 + a++= -> =1 + 1= -> =2=
=a= -> =2=
=1 + (++a)= -> =1 + 3= -> =4=
=a= -> =3=
=1 + a--= -> =1 + 3= -> =4=
=a= -> =2=
=1 + (--a)= -> =1 + 1= -> =2=
=a= -> =1=

变量不能放入不同类型的数据，但把小数放到整数的盒子里肯定是常见的操作，这种不同类型的数据之间的操作 =C= 是支持。 =C= 会对不同类型的数据自动进行类型转换，转换的规则是尽量减少信息的流失，比如 =short= 和 =int= 类型的数据运算，返回的结果是 =int= 类型的数据。小数转换成整数会直接把小数部分去掉，并不会四舍五入。
对于赋值运行也是相同的道理
** 输入输出
*** 简介
我们写一个程序，一般都是面向用户的，作为人类我们肯定是需要获取和输入一些信息，一个无法干涉无法感知的东西我们是不能使用的。

下面我就介绍下 =C= 里的标准输入输出，标准输入输出可以理解成通用的接口，一般情况下我们都可以使用这个接口来输入输出信息。
一般情况输入输出都是文本的形式。

需要注意 =C= 默认不包含输入输出的功能，我们需要引入这些功能， =stdio.h= 这个头文件包含了我们需要的功能，使用 =#include <stdio.h>= 这个命令我们可以引入它。
可以简单的把这个命令理解成把 =stdio.h= 这个文件里的内容放到我们程序的最前面。

函数也可以理解成一个魔法盒子，它可以放入一些数据，然后扔出一些数据。

*** 输出
**** putchar
这个函数很容易理解，传入一个字符，并把它输出， =c= 可以使用 =''= 包裹一个字符来表示一个字符常量，如果 =''= 内有多个字符就会报错。

=putchar('a')= 语句输出 =a= 到标准输出。
**** puts
同理这个函数也是传入一个字符串，并输出它，与字符的表示方式相似，我们使用 =""= 包裹多个字符来表示字符串变量。

比如 =puts("Hello")= 语句就会输出 =Hello= 到标准输出。
**** printf
格式化输出一串字符，它接收任意多个参数，第一个参数是一个字符串，并把它作为模板，里面可以放一些标识来表示需要把标识替换成我们想要的数据，后面的参数填入表达式，函数会按顺序把它们一个个填入模板字符串中。

#+begin_src c
#include <stdio.h>

int main() {
  /* 语句后面的注释里放输出的内容 */
  /* \n是转义字符，表示换行，因为有些字符不可输入 */
  printf("%d is a number\n", 123); /* 123 is a number */
  printf("%s is a string, and i like %c", "haha", 'a');/* haha is a string, and i like a */
  return 0;
}
#+end_src

*** 输入
**** getchar
这个函数从标准输入读入一个字符然后返回，比如 =char c = getchar();= 这条语句就会从输入流获取一个字符，并赋值给变量 =c= 。

=getchar= 只从输入拿下一个字符，所有的字符都可以拿下来，包括空白字符（空格、回车等等）
**** gets
这个函数从标准输入读取一行字符，并把这一行填入一个字符数组。

#+begin_src c
#include <stdio.h>

int main() {
  char s[100];  /* 字符串可以理解成多个字符，所以c里面使用数组来表示字符串 */
  gets(s);      /* 与上面的getchar不同，它不会返回一个值 */
  puts(s);      /* 输出一个字符串 */
  return 0;
}
#+end_src

请注意一行末尾的回车不会被填入字符数组。
**** scanf
这个函数就可以支持多种形式格式的输入了，与上面的 =printf= 有相同的控制符。
需要注意一点， =scanf= 填写变量的位置需要提供一个指针，获取变量指针的方法是使用 =&= 运算符。
使用 =%c= 时和 =getchar= 一样会读取空白字符
使用 =%s= 时只要遇到一个空白字符就会停止

#+begin_src c
#include <stdio.h>

int main() {
  int n;
  char s[100];
  /* n是一个变量需要使用 & 获取它的指针
   * 而数组名就是一个指针 */
  scanf("%d %s", &n, s);
  printf("%d %s\n", n, s);
  return 0;
}
#+end_src

** 选择
*** 简介
选择结构的出现打破了我之前讲述的简洁明了的语法，我们需要重新学习一些额外的情况，所幸这种新结构并不复杂。

选择结构有三种表达方式， =if= 、 =switch= 、 =三元运算符=
前面两种方式可以相互转换，而最后一种出现的目的是减少代码行数，同时也加重了我们理解程序的负担。

需要注意一点，在选择结构内如果执行了 =break= 会直接结束当前的选择结构。
*** if
它的语法大概是这样 =if (表达式) { 代码块 }=
简单来说如果对表达式求值的结果为真，就执行使用 ={}= 包裹的代码块
=c= 里面使用 =0= 表示假，而其它的任何值都为真
所谓代码块就是任意行语句

如果需要执行的语句只有一行可以使用 =if (表达式-判断) 表达式-执行;= 的形式，表达式可以不写。

如果我们还要对表达式为假的情况做些操作，并不用再写一个 =if= ，可以使用下述方式
=if (表达式) {为真时执行} else {为假时执行}=
同理，只有一条语句时可以省略 ={}=
下面看一个例子

#+begin_src c
#include <stdio.h>

int main() {
  int a = 10;
  if (a < 20)
    puts("a < 20\n");
  
  if (a > 100)
    puts("a > 100");
  else
    puts("a <= 100");

  if (a > 10)
    puts("a > 10\n");
  else if (a < 10)
    puts("a < 10\n");
  else
    puts("a == 10\n");
  return 0;
}
#+end_src
*** switch
=switch= 的语法比较复杂，简单来说它会把你给予的一个整数与 =case= 语句从上到下一一比对
如果跟 =case= 语句后面的值相等，就执行 =case= 对应的代码块
=default= 表示没有一个 =case= 语句匹配时的情况

#+begin_src c
#include <stdio.h>

int main() {
  switch(10) {
    case 10:
      puts("10");
    case 9:
      puts("9");
    default:
      puts("not match");
  }
  return 0;
}
#+end_src

需要注意，有匹配项后它会忽略当前 =case= 后面的所有 =case= 条件，即它会执行匹配 =case= 后面的所有语句，直到 =switch= 结构结束。
所以我们一般对于每个 =case= 都会在它的结尾加上 =break=
*** 三元运算符
它的语法比较简单 =条件?表达式1:表达式2=
对这个三元运算表达式求值时，如果条件为真就执行并返回表达式1的值，否则执行并返回表达式2的值

#+begin_src c
#include <stdio.h>

int main() {
  int a, b;
  scanf("%d %d", &a, &b);
  printf("the max number is:%d\n", a > b ? a : b);
  return 0;
}
#+end_src
** 循环
*** 简介
我们继续来破坏 =c= 的简单性，这次介绍循环结构
有两种方式来描述一个循环结构 =while= 、 =for=
*** while
语法为 =while(条件) {代码块}=
与 =if= 的结构相似，与 =if= 不同的地方在于， =while= 会在代码块执行结束后重复检查条件，如果条件还是为真就继续执行代码块
简单来说就是执行代码块直到条件为假。

#+begin_src c
#include <stdio.h>

int main() {
  int a = 10, sum = 0;
  while (a > 0) {
    sum += a;
    a--;
  }
  printf("%d\n", sum);
  return 0;
}
#+end_src

=while= 还有一种变形 =do while= ，它的语法为
=do {代码块} while(条件);=
与 =while= 的差别就是它一定会执行一次代码块
*** for
语法为： =for (初始化;条件;副作用){代码块}=
=for= 可以转换成 =while= 的形式
=初始化;while(条件){代码块;副作用;}=
初始化部分会在代码块之前执行，并且只执行一次
每次条件为真时会执行代码块
而副作用部分会在每次代码块结束后执行

=for= 可以理解成 =while= 的严格模式，它让你把一些容易忘记写的部分先写好，尽量避免出错的可能性，比如写 =while= 语句时有人可能就忘记在末尾加上递增语句了。

#+begin_src c
#include <stdio.h>

int main() {
  int a = 10, sum = 0;
  for (a = 10; a > 0; a--) {
    sum += a;
  }
  printf("%d\n", sum);
  return 0;
}
#+end_src

** 数组
*** 简介
数组提供了简单声明多个变量的方法，假设你需要对100个数进行排序，如果采用以往声明变量的方式，你需要写100个变量名，而使用数组就能一行语句生成多个变量。
*** 语法
数组的语法非常简单 =类型名 数组名[数组大小]=
类型名和数组名与变量的声明相同，数组与变量的区别只在于后面的那个括号，括号定义了数组里包含多少个元素，使用 =数组名[下标]= 可以找到任意一个元素，而它的使用方式与普通变量并无区别
声明数组后，数组的大小不可改变，如果下标超过声明的大小，程序可能会发生错误
既然声明后不可改变大小，而一次想好数组大小是一件很头疼的事情，那么可以不可以让数组的大小跟随数据变化呢？
比如我知道了有100个数据，那么我只用开一个长度为100的数组即可
对于 =vc++= 这些使用低版本编译器的 =IDE= 来说这是不可行的，因为低版本的编译器 =[]= 内只能放常量
但如果你使用 =Dev-C++= 的话就不用但这个问题，它是可以在 =[]= 内放表达式的

注意第一个元素的下标为0

我们对于 =类型名 数组名[行数][列数]= 这种形式的数组称为二维数组，同理我们能够声明任意维度的数组
对于二维数组，使用它时必须填好两个 =[]= 内的内容，你可以简单画一个表格，这样方便理解
*** 插入排序
#+begin_src c
#include <stdio.h>

int main() {
  int len, i, j;
  scanf("%d", &len);        /* 输入数组长度 */
  int arr[len];             /* 动态定义数组 */
  for (i = 0; i < len; i++) /* 输入数据 */
    scanf("%d", arr + i);

  /* 使用插入排序，下面介绍一下原理
   * 简单来说对于每个i，找到i后面最小的元素，并让它与i位置的元素交换
   * 也既保持每个i上的元素都比之后的元素小 */
  for (i = 0; i < len; i++)
    for (j = i + 1; j < len; j++)
      if (arr[i] > arr[j]) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
      }

  /* 输出数据 */
  for (i = 0; i < len; i++)
    printf("%d ", arr[i]);
  printf("\n");
  return 0;
}
#+end_src
** 指针
*** 简介
前面我们介绍了变量，变量我把它形容成一个盒子，盒子可以往里面放或拿东西
现在想像一下，我们把所有的盒子都放到地上，按顺序一个一个编号
如果有人想用盒子就标记一下这个盒子被占用了，并自己记下盒子的编号，然后就可以自由使用这个盒子了
这个编号我们就称之为地址，而指针也是一个盒子，但它里面装着的东西只能是地址，也即一个地址类型的变量
或者可以想像成一个里面放着纸条的盒子，纸条上写着一个盒子的地址
*** 语法
=类型 *指针名= 就可以声明一个指针了
需要注意一下 =int* a, b= 并不会声明指针 =a= =b= ，而是声明一个指针 =a= 与一个变量 =b=
所以写代码时请让 =*= 挨着指针名
*** 用法
指针可以放地址，但是我们怎么获得一个地址呢？
有些同学可能已经想到了，我们之前用 =scanf= 的时候使用一个操作符 =&=
使用 =&变量= 的方式，我们就能获得变量的地址了
但我们对指针求值得到的结果是一个地址，那么我们怎么使用指针指向的变量呢？
很简单，我们可以使用 =*指针= 的方式来找到那个地址
通俗来说，跟着盒子内的纸条找到另一个盒子
=*指针= 和普通变量的用法是一样的
*** 数组
对于数组来说，数组名其实是一个指针，它保存的是数组的起始地址
我们先定义一个数组 =int arr[10]=
我们可以发现 =arr[2]= 和 =*(arr+2)= 的效果是一样的，其实 =arr[2]= 是一个[[https://baike.baidu.com/item/%E8%AF%AD%E6%B3%95%E7%B3%96][语法糖]]
=arr+2= 的意思就是找到 =arr= 之后两个位置的地址
需要注意指针会自动识别一个单元格的大小

还记得之前我们说过 =vc++= 不能动态定义数组长度吗？
现在我们通过指针来实现这一功能
首先先引入 =stdlib.h= 库，我们要使用 =malloc= 函数，这个函数可以让我们向系统申请内存，也就是和盒子的例子一样，我们登记一个盒子
然后这样 =int *arr = (int *)malloc(sizeof(int) * len)= 就可以定义一个len长度的数组了

#+begin_src c
#include <stdio.h>
#include <stdlib.h>

int main() {
  int len, i, j;
  scanf("%d", &len);                           /* 输入数组长度 */
  int *arr = (int *)malloc(sizeof(int) * len); /* 动态定义数组 */
  for (i = 0; i < len; i++)                    /* 输入数据 */
    scanf("%d", arr + i);

  /* 使用插入排序，下面介绍一下原理
   * 简单来说对于每个i，找到i后面最小的元素，并让它与i位置的元素交换
   * 也既保持每个i上的元素都比之后的元素小 */
  for (i = 0; i < len; i++)
    for (j = i + 1; j < len; j++)
      if (arr[i] > arr[j]) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
      }

  /* 输出数据 */
  for (i = 0; i < len; i++)
    printf("%d ", arr[i]);
  printf("\n");
  return 0;
}
#+end_src
** 函数
*** 简介
函数让我们可以把一堆操作封装起来，下次可以直接使用，数学一点的像pi、cos、sin等都可以用函数封装起来，再比如打印一行星号、对数组进行排序、计算fib数列之类的。

如果你以后开发一个比较大型的应用，把所有语句写在 =main= 函数里当然也可以，但如果你突然发现一个功能写错了，那么你可以会痛苦的找上很久 =bug= 。
而如果你模块化的把每个功能都封装好成一个个函数，那么你就能单独的测试每个函数，更妙的是如果你把每个函数的名字起的好，那么你的程序就可以像读文章一样，不需要注释也能读懂。
*** 语法
=返回类型 函数名(类型1 参数1，类型2 参数2){函数体}= 就可以创建一个函数
每个函数都要定义好返回类型，函数可以有多个参数，每个参数都必须定义类型，因为 =c= 是强类型的语言
变量进入函数时，函数并不会使用原来的变量，而是把变量里的内容复制到一个新建的变量，记住这一点！！！
函数只能有一个返回值，那么我想返回多个值怎么办呢？
我们可以返回一个结构体
*** 例子
我们来简单的举一个例子，交换变量里的值
我们先看看错误的例子

#+begin_src c
#include <stdio.h>

void swap(int a, int b) {
  int temp = a;
  a = b;
  b = temp;
}

int main() {
  int a, b;
  scanf("%d %d", &a, &b);
  swap(a, b);
  printf("%d %d\n", a, b);
  return 0;
}
#+end_src

对于这个例子，它的关键点是 =swap= 函数，为什么在函数里已经交换了变量，但输出的结果却和输入一样呢？
原因已经在语法里说过，函数内的变量并不是从函数外进入的变量，函数内的变量只是复制了他的值，所以你无论在函数内做什么操作，都不会影响到函数外的变量。
那我们怎么办呢？
现在又到指针登场的环节了

#+begin_src c
#include <stdio.h>

void swap(int *a, int *b) {
  int temp = *a;
  *a = *b;
  *b = temp;
}

int main() {
  int a, b;
  scanf("%d %d", &a, &b);
  swap(&a, &b);
  printf("%d %d\n", a, b);
  return 0;
}
#+end_src

可以看到我把两个指针作为参数，然后我把 =a= =b= 的地址传入了函数，这样虽然只把值复制了过去，但我们已经知识了地址，所以直接修改地址指针的内存即可。

** 递归
*** 简介
首先，我们可以确定一点，函数内是可以使用函数的，这点一开始就可以从在 =main= 函数内使用 =printf= 看出。
那么你有没有想过，如果我在函数内使用自己会怎么样呢？
可以预见，没有特殊措施的话，程序会疯狂的循环
但只要函数有最小值，并且每次递归时输入的规模都会减少，这个函数还是会停止的
*** fib
对于fib数列，它在数学是这样定义的
\begin{equation}
fib(n)=\left\{
\begin{array}{cc}
0 & {n=0}\\
1 & {n=1}\\
1 & {n=2}\\
fib(n-1)+fib(n-2) & {n>2}
\end{array}
\right.
\end{equation}

可以看到上面是 =fib= 函数的定义，我们只需要把它转换成 =c= 的形式即可

#+begin_src c
#include <stdio.h>

int fib(int n) {
  if (n == 0)
    return 0;
  if (n < 2)
    return 1;
  return fib(n - 1) + fib(n - 2);
}

int main() {
  int n;
  scanf("%d", &n);
  printf("%d\n", fib(n));
  return 0;
}
#+end_src

从这个例子可以看出对于数学上的东西，使用递归是最好写的，但这也说明了，理解需要一定的数学思维，毕竟现实世界上人可不能把自己提起来。

为什么函数自己调用自己时不会产生混乱呢？
因为 =c= 每次执行函数时，都是新生成了一个机器。如果我们把函数定义比做一张蓝图，那么执行函数时我们就制作了一个机器来运行，也就是每次执行的函数都是一个全新的机器，我在这台机器做的操作当然不会同步到另一台机器，而之前的一台机器也会耐心等待后面的机器运行完毕后，再把返回的结果拿过来。

** 结构体
*** 简介
结构体提供了一个把多种类型，多个变量集合到一起的功能
比如我想保存一个学生的数据，对于学生他有年龄、名字、学号、性别...
我们当然可以直接定义多个变量，但如果我想把这些数据传入函数处理，那么就要输入很多变量，而如果我想返回一个学生的数据，那我们只能使用丑陋又危险的全局变量了
或者，我们可以简单的使用结构体来解决这些问题
*** 语法
结构体其实是声明了一个类型，很奇怪吧，我们之前声明过很多东西，但没想到类型也可以自定义吧
类型就意味着，使用结构体时，我们是使用一个结构体类型的变量
下面我们就直接来看代码

#+begin_src c
#include <stdio.h>

/* 定义了一个结构体类型stu */
struct stu {
  /* 学号和年龄 */
  int no, age;
  /* 性别和名字 */
  char sex, name[20];
};

void prtstu(struct stu a) {
  printf("学号：%d 年龄：%d 性别：%c 名字：%s\n", a.no, a.age, a.sex, a.name);
}

int main() {
  /* struct表示它是一个结构体类型 */
  struct stu xiami;
  /* 使用.运算符可以使用结构体内的变量 */
  scanf("%d %d %c %s", &xiami.no, &xiami.age, &xiami.sex, xiami.name);
  prtstu(xiami);
  return 0;
}
#+end_src
*** 结构体指针
我们来看一个很魔鬼的东西，结构体指针
顾名思义，结构体指针就是存放着结构体变量地址的变量
使用 =struct stu *p= 就定义了一个学生类型的结构体指针， =p= 可以指向一个结构体变量的地址了
现在我们再声明一个结构体变量 =struct stu a= ，把 =p= 指向这个变量 =p = &a=
现在我们想知道a的年龄就可以这样 =(*p).age=
因为 =.= 的优先级高于 =*= 所以必须用一个括号括起来
这个方式太过麻烦，跟不用 =[]= 的数组一样，那么官方有没有做一个对应的语法糖呢？
幸运的是还真有，使用 =->= 即可， =p->ag= 就可以查看 =a= 的年龄了
* C++
** stl
=c++= 是 =c= 的超集，也就是说 =c++= 支持所有 =c= 的语法，并在此基础上 =c++= 又新增了一些语法与工具。更重要的区别在于 =c= 是面向过程的，而 =c++= 是面向对象的。

对于我们做算法竞赛的同学来说， =c++= 最重要的功能就是 =stl= 了，它内置了许多有用的工具，这使得我们不需要一切都从轮子写起。

=namespace= 即命名空间，不同于 =c= 在 =c++= 里提供了一种分隔代码的好方法，我们可以为一类变量函数增加一个命名空间，使用 =空间名::变量名= 就可以使用这个命名空间内的东西， =stl= 就是这样做的，它为每个变量与函数都设置了名为 =std= 的命名空间。但这个东西其实非常的麻烦，每个函数我都要加上5个字符，所以可以使用 =using namespace std;= 来导入这个命名空间，让它所有的变量与函数暴露出来。

但这也引出了一个问题， =std= 下的内容太多了，像 =min= 、 =max= 、 =next= 、 =count= 等等常用的名字都被使用了，所以我们必须避开他们，使用其它的名字。
** 输入输出
*** 头文件
=c++= 的输入输出头文件叫 =iostream= ，引用使用 =#include <iostream>= 语句

可以发现，头文件后面并没有 =.h= ，这是 =c++= 与 =c= 的不同，所有新增的头文件都不能加 =.h=
*** cin
使用 =cin >> 变量名= 可以从标准输入把数据输入变量内，需要注意的是输入时不需要加标识符来表示变量的类型， =c++= 可以自己确定变量的类型，并根据类型自己确定会输入的数据。

=cin >> 变量名1 >> 变量名2 >> 变量名3= 它的后面可以接许多个变量，变量的输入是从左至右依次进行， =>>= 可以把想像成数据流入了变量。
*** cout
同理 =cout << 表达式= 就可以向标准输出输出内容了， =cout= 也会自动判断表达式返回值的类型，但相比 =printf= 它就不能做到精准的格式输出了，比如固定4位宽度的数字使用 =cout= 就比较难以做到了。
*** 总结
对于输入没有规定必须使用哪个，挑选最合适的就行了。
** vector
*** 头文件
=#include <vector>=
*** 简介
=vector= 翻译成中文叫向量
它可以理解成一个动态数组，它的长度可以自由调整
*** 创建
=vector<类型名> 数组名= 就可以创建一个 =vector= 了
不止如此， =vector= 支持初始化时自定义长度与初始内容
=vector<int> v1(3)= 创建了长度为3，元素默认值为0的 =vector=
=vector<int> v2(5, 10)= 创建了长度为5，元素默认值为10的 =vector=
=vector<int> v3(v1)= 创建了和 =v1= 内容一样的 =vector=
*** 使用
可以直接使用 =[]= 像数组一样访问 =vector=
=vector= 因为是一个对象，它内置了一系列函数，其中有一个名为 =at()= 的函数也可以访问对应下标的元素，但如果下标越界了它会直接抛出异常

下面我介绍几个常用的函数：
=size()= 返回向量的长度
=empty()= 如果向量为空则返回真
=begin()= 返回向量第一个元素的引用（地址）
=end()= 返回向量最后一个元素之后一个长度的引用
=push_back()= 在向量后面加入一个元素
=pop_back()= 删除向量最后一个元素
=insert()= 在某个位置插入元素

=vector= 也重载了一些运算符
使用 =v1=v2= 可以直接赋值
使用 =v1==v2= 可以轻松的判断两个向量是否完全一致
使用 =v1>v2= 可以判断两个向量的大小问题，它从第一个元素开始对比，如果当前 =v1= 元素不等于 =v2= 直接返回它们之间的大小，如果相等就同时向后延一格对比

** string
*** 头文件
=#include <string>=
*** 简介
=string= 是一个字符串，它的底层实现是 =vector= 它可以使用 =vector= 的所有函数，它也新加了许多方便的方法
*** 使用
它的创建方法与 =vector= 一样，这些可以直接看上面的 =vector= 介绍

对于字符串来说它有两个方法非常常用
=find()= 可以查找子串第一次出现的位置，函数可以传入字符或字符串
=substr(pos, len)= 从 =pos= 开始开始截取 =len= 个字符并返回它
** queue
*** 头文件
=#include <queue>=
*** 简介
=queue= 叫做队列，它是一种数据结构，先进入队列的数据会先出来，可以想像一个管子，从后面往里面塞球，取球时只能从前面取

还有一个叫双端队列的类 =deque= ，与 =queue= 的不同在于， =deque= 可以从两边取和删除数据

为什么要使用队列呢？我使用数组也可以做到相同功能
原因就是数组在前端插入一个数据需要遍历整个数组，但队列只需要一下操作就能实现，这在数据量大的情况下是有利的。
简单来说 =queue= 的修改是 =O(1)= 的，而数组的修改是 =O(n)= 的。
*** 使用
=queue<类型名> 队列名= 就可以创建一个队列了，初始化的方法与之前的方法一致

=queue= 的函数：
=empty()= 返回队列是否为空
=push()= 向队尾插入一个元素
=pop()= 队首弹出一个元素
=front()= 查看队首的元素

=deque= 的函数：
=push_front()= 在队首插入元素
=pop_front()= 弹出队首的元素
=push_back()= 在队尾插入元素
=pop_back()= 弹出队尾的元素
=at()= 通过下标访问元素

** stack
*** 头文件
=#include <stack>=
*** 简介
=stack= 是栈，与队列相反，栈只能在一端插入或删除，就像一个筒装薯片一样，你可以在开口处拿薯片或放入薯片，可以发现栈的元素是后进先出的。

我们的递归函数底层使用了栈，有时写算法题时直接使用递归可能会爆内存，这时可以使用栈来模拟递归。
*** 使用
=stack<类型名> 栈名= 与之前初始化一样的方法

=stack= 的函数主要有：
=back()= 获取尾部元素
=push_back()= 向尾部推入一个元素
=pop_back()= 从尾部弹出一个元素

可以发现，使用 =deque= 可以模拟 =stack=
** set
*** 头文件
=#include <set>=
*** 简介
=set= 是集合，和数学上的集合一样，每个元素只能出现一次，这对于统计有多少个不同的元素是很方便的。

顺便说一句， =set= 的复杂度都 =O(logN)= 的，它的底层实现是红黑树
*** 使用
=set<类型名> 集合名= 创建一个 =set=

=set= 的函数有：
=insert()= 插入一个元素
=erase()= 删除元素
=clear()= 清空集合
=find()= 在集合内查找元素，并返回它在集合内的引用
=count()= 统计元素在集合内的个数，它的返回值只能是1或0
=empty()= 返回集合是否为空
=size()= 集合的元素个数
** map
*** 头文件
=#include <map>=
*** 简介
=map= 的意思其实是映射，它可以保存 =key= 到 =value= 的映射，也就是键值对
说人话，就像数组可以通过下标访问元素， =map= 也是通过 =key= 访问元素，不同于数组 =map= 的 =key= 可以是数字、字符、字符串等等
一个 =key= 只能映射到一个 =value=

=map= 的复杂度也都是 =O(logN)=
*** 使用
=map<键类型, 值类型> 映射名= 可以创建一个 =map= 需要标注好键和值的类型

使用方法和数组类似 =map1[键]= 就可以返回对应键的值了

比如 =map<char, int> m= 创建了名为 =m= 的映射，它可以把一个字符映射到一个整数数字上
=m['a'] = 100= 就把100保存到a这个键内了
=m['a']= 对这个表达式求值就返回100了

=map= 的函数：
=count()= 统计一个键的数量
=find()= 返回对应键在映射内的指针
=size()= 返回全部元素个数
=empty()= 返回映射是否为空
** sort
*** 头文件
=#include <algorithm>=

这个头文件内有许多算法的实现，比如等下要讲的排序
*** 简介
=sort= 是排列的意思，它可以对给定范围内的数据进行排序，传入一个比较函数就可以控制是从小到大还是从大到小排序了。

=sort= 排列的复杂度是 =O(n*logN)=
*** 用法
=sort(起始引用,未尾引用)= 就可以对这个范围内的数据排序了，需要注意未尾引用是最后一个元素的引用加1

不需要指定被排序数据的类型， =sort= 会自动判断
可以为第三个参数添加一个比较函数，让 =sort= 使用这个函数的规则排序

#+begin_src c++
#include <algorithm>
#include <iostream>
#include <vector>

using namespace std;

bool cmp1(int a, int b) { return a > b; }

int main() {
  vector<int> a = {9, 6, 3, 8, 5, 2, 7, 4, 1, 0};
  sort(a.begin(), a.end());
  for (int i = 0; i < a.size(); i++)
    cout << a[i] << " ";
  cout << endl;

  sort(a.begin(), a.end(), cmp1);
  for (int i = 0; i < a.size(); i++)
    cout << a[i] << " ";
  cout << endl;

  int b[] = {9, 6, 3, 8, 5, 2, 7, 4, 1, 0};
  sort(b, b + 10);
  for (int i = 0; i < 10; i++)
    cout << b[i] << " ";
  cout << endl;

  sort(b, b + 10, cmp1);
  for (int i = 0; i < 10; i++)
    cout << b[i] << " ";
  cout << endl;
  return 0;
}
#+end_src
** next_permutation
*** 头文件
=#include <algorithm>=
*** 简介
=next_permutation= 可以生成一个范围内数据的下一个排列
比如 =1 2 3= 的下一个排列就是 =1 3 2=
这个函数的作用是非常大的，以后做有些算法题时，如果不想用递归写 =dfs= 可以使用这个函数解决

比如有一些人想接水，每个人接水的时间不同，我们想让所有人的等待时间之和最小，使用暴力的方法，把这些人的每种排列情况都算一遍就能得到答案了，当然这道题使用其它的方法更简单
*** 使用方法
=next_permutation(起始引用,未尾引用)= 会生成范围内的下一个排列，如果不能生成了就返回 =false=

#+begin_src c++
#include <algorithm>
#include <iostream>

using namespace std;

int main() {
  int all[] = {1, 2, 3, 4, 5};
  do {
    for (int i = 0; i < 5; i++)
      cout << all[i] << " ";
    cout << endl;
  } while (next_permutation(all, all + 5));
  return 0;
}
#+end_src
* 结语
这篇文章只讲解了 =C/C++= 的一下部分内容，如果你对其它的部分也感兴趣的话，我推荐一本书 《C++ Prime Plus》
